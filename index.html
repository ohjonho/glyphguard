<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GlyphGuard - Roguelike Typing Defense</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            color: #ffffff;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            image-rendering: pixelated;
            overflow-x: hidden;
        }
        
        h1 {
            text-align: center;
            color: #00ff41;
            text-shadow: 2px 2px 0px #008f11, 4px 4px 0px #000000;
            margin: 20px 0;
            font-size: clamp(16px, 4vw, 24px);
            letter-spacing: 3px;
            font-weight: bold;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
        }
        
        #gameContainer {
            border: 4px solid #00ff41;
            background: #000000;
            position: relative;
            border-radius: 0;
            box-shadow: 
                0 0 20px #00ff41,
                inset 0 0 20px rgba(0, 255, 65, 0.1);
            max-width: 95vw;
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(90deg, #001122 0%, #002244 30%, #003366 70%, #004488 100%);
            image-rendering: pixelated;
        }
        
        #gameUI {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        #wordInput {
            padding: 15px;
            font-size: clamp(12px, 2.5vw, 16px);
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            border: 3px solid #00ff41;
            border-radius: 0;
            background: #000000;
            color: #00ff41;
            width: min(400px, 80vw);
            text-align: center;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        #wordInput:focus {
            outline: none;
            background: #001100;
            box-shadow: 0 0 15px #00ff41;
        }
        
        #wordInput.invalid {
            background: #220000;
            border-color: #ff0000;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        #gameStats {
            display: flex;
            gap: clamp(20px, 5vw, 40px);
            font-size: clamp(10px, 2vw, 14px);
            font-weight: bold;
            background: rgba(0, 255, 65, 0.1);
            padding: 12px 20px;
            border: 2px solid #00ff41;
            flex-wrap: wrap;
            justify-content: center;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            letter-spacing: 1px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 1px 1px 0px #000000;
        }
        
        .health { color: #ff4444; }
        .score { color: #ffff44; }
        .wave { color: #44ff44; }
        .enemies { color: #ff8844; }
        .timer { color: #44ffff; }
        
        #feedback {
            height: 40px;
            font-size: clamp(10px, 2vw, 12px);
            font-weight: bold;
            display: flex;
            align-items: center;
            text-align: center;
            min-width: min(400px, 80vw);
            justify-content: center;
            text-shadow: 1px 1px 0px #000000;
        }
        
        .success { 
            color: #44ff44; 
            animation: glow 1s ease-in-out;
        }
        .error { 
            color: #ff4444; 
            animation: glow 1s ease-in-out;
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 1px 1px 0px #000000; }
            50% { text-shadow: 0 0 10px currentColor, 1px 1px 0px #000000; }
        }
        
        #unitGuide {
            position: relative;
            width: 275px;
            max-width: 90vw;
            z-index: 10;
            border-radius: 8px;
            box-shadow: 0 0 10px #00ff41;
            margin: 20px auto 0 auto;
            transform: scale(0.9);
            transform-origin: top center;
        }
        @media (max-width: 900px) {
            #unitGuide {
                display: none;
            }
        }
        #unitInfoModal {
            position: fixed;
            pointer-events: none;
            background: rgba(0,0,0,0.95);
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            z-index: 10000;
            min-width: 120px;
            box-shadow: 0 0 10px #00ff41;
            display: none;
        }
        
        .unit-type {
            display: inline-block;
            margin: 13px 0;
            padding: 11.3px 8.1px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff41;
            font-size: 0.89em;
            transition: all 0.2s ease;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-weight: bold;
        }
        
        .unit-type:hover {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 5px #00ff41;
        }
        
        .overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border: 4px solid #00ff41;
            text-align: center;
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 30px #00ff41;
        }
        
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 4px solid #00ff41;
            text-align: center;
            box-shadow: 0 0 30px #00ff41;
            max-width: 90vw;
        }
        
        .upgrade-options {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .upgrade-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            padding: 20px;
            width: min(200px, 25vw);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: clamp(8px, 1.2vw, 10px);
        }
        
        .upgrade-card:hover {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 15px #00ff41;
            transform: translateY(-3px);
        }
        
        .upgrade-title {
            font-size: clamp(10px, 1.5vw, 12px);
            color: #00ff41;
            margin-bottom: 10px;
        }
        
        .upgrade-description {
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .upgrade-stats {
            color: #44ff44;
            font-size: clamp(8px, 1vw, 10px);
        }
        
        .button {
            padding: 15px 25px;
            font-size: clamp(10px, 1.5vw, 12px);
            background: #00ff41;
            color: #000000;
            border: none;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .button:hover {
            background: #44ff44;
            box-shadow: 0 0 10px #00ff41;
            transform: translateY(-2px);
        }
        
        .instructions {
            font-size: clamp(8px, 1.2vw, 10px);
            color: #cccccc;
            margin-top: 20px;
            line-height: 1.6;
        }
        
        .leaderboard {
            margin-top: 20px;
            background: rgba(0, 255, 65, 0.1);
            padding: 15px;
            border: 1px solid #00ff41;
            font-size: clamp(8px, 1.2vw, 10px);
        }
        
        #wordLog {
            position: fixed;
            top: 20px;
            left: 20px;
            right: auto;
            width: min(200px, 25vw);
            max-height: 300px;
            overflow: hidden;
            pointer-events: none;
            z-index: 1000;
        }
        
        .word-entry {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            margin: 2px 0;
            border-left: 3px solid #00ff41;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: clamp(8px, 1vw, 10px);
            text-align: right;
            transition: opacity 0.5s ease;
            text-transform: uppercase;
            font-weight: bold;
        }
        
        .word-entry.success {
            border-left-color: #44ff44;
            background: rgba(68, 255, 68, 0.2);
        }
        
        .word-entry.error {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
        }
        
        .retro-glow {
            text-shadow: 0 0 5px currentColor;
        }
        
        .pixel-border {
            border-style: solid;
            border-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="%2300ff41"/></svg>') 1;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            #gameContainer {
                border-width: 2px;
            }
            
            .upgrade-options {
                flex-direction: column;
                align-items: center;
            }
            
            .upgrade-card {
                width: 80vw;
            }
        }
        /* In <style>, update font sizes and weights for all major UI elements: */
        body, h1, #gameUI, #gameStats, .stat, #feedback, #unitGuide, .unit-type, .button, .instructions, .leaderboard, #wordInput, .overlay-screen, #unitInfoModal {
            font-size: 1.15em;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        #gameStats {
            font-size: clamp(14px, 2.5vw, 18px);
            font-weight: 700;
        }
        #feedback {
            font-size: clamp(14px, 2vw, 16px);
            font-weight: 700;
        }
        #unitGuide {
            width: 275px;
            padding: 25.9px 22.7px 22.7px 22.7px;
            font-size: 0.97em;
            font-weight: 700;
            background: rgba(0, 255, 65, 0.10);
            border: 3px solid #00ff41;
            border-radius: 16px;
            box-shadow: 0 0 18px #00ff41;
        }
        .unit-type {
            font-size: 0.99em;
            font-weight: 700;
            margin: 14.4px 0;
            padding: 12.6px 9px;
            border-radius: 8px;
            background: rgba(0,0,0,0.15);
        }
        .button {
            font-size: 1.15em;
            font-weight: 700;
            padding: 18px 32px;
        }
        .overlay-screen, #unitInfoModal {
            font-size: 1.15em;
            font-weight: 700;
        }
        .instructions {
            font-size: 1.1em;
            font-weight: 700;
        }
        .leaderboard {
            font-size: 1.1em;
            font-weight: 700;
        }
        #wordInput {
            font-size: 1.2em;
            font-weight: 700;
            padding: 18px;
        }
        .overlay-screen, #armoryScreen, .upgrade-card, .upgrade-title, .upgrade-description, .upgrade-stats {
            font-size: 1.265em;
        }
        
        /* Add Armory Menu animation */
        @keyframes armoryFadeGlow {
            0% { opacity: 0; box-shadow: 0 0 0px #00ff41; }
            40% { opacity: 1; box-shadow: 0 0 30px #00ff41; }
            100% { opacity: 1; box-shadow: 0 0 10px #00ff41; }
        }
        #armoryScreen.armory-animate {
            animation: armoryFadeGlow 0.7s ease;
        }
        /* Armory Menu font size/style fix */
        #armoryScreen, #armoryScreen h2, #armoryScreen p, #armoryScreen .upgrade-options, #armoryScreen .upgrade-card, #armoryScreen .upgrade-title, #armoryScreen .upgrade-description, #armoryScreen .upgrade-stats {
            font-size: 0.95em !important;
            font-weight: 700 !important;
            letter-spacing: 0.5px;
        }
        #armoryScreen .upgrade-card {
            font-size: 0.95em !important;
        }
        #armoryScreen .upgrade-title {
            font-size: 0.93em !important;
        }
        #armoryScreen .upgrade-description {
            font-size: 0.91em !important;
        }
        #armoryScreen .upgrade-stats {
            font-size: 0.89em !important;
        }
        #armoryScreen .upgrade-card {
            padding: 12px 10px;
            margin: 8px;
            width: 90%;
            min-width: 0;
            max-width: 320px;
            font-size: 1.08em !important;
        }
        #armoryScreen .upgrade-title {
            font-size: 1em !important;
            margin-bottom: 6px;
        }
        #armoryScreen .upgrade-description {
            font-size: 0.98em !important;
            margin-bottom: 8px;
        }
        #armoryScreen .upgrade-stats {
            font-size: 0.95em !important;
        }
    </style>
</head>
<body>
    <div id="scoreAboveTitle" style="position: absolute; top: 18px; right: 40px; color: #ffff44; font-size: 1.3em; font-weight: bold; text-shadow: 1px 1px 0px #000; z-index: 100;">SCORE: 0</div>
    <div id="waveBanner" style="display:none; position:fixed; top:40px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.92); color:#00ff41; font-size:2em; font-family:'Courier New',monospace; font-weight:bold; border:3px solid #00ff41; border-radius:12px; padding:18px 48px; z-index:2000; box-shadow:0 0 24px #00ff41; letter-spacing:2px; opacity:0; transition:opacity 0.7s;"></div>
    <h1>⚔️ GLYPHGUARD ⚔️</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="mainMenu">
            <h1 style="font-size: clamp(16px, 3vw, 24px); margin-bottom: 20px; color: #00ff41;">⚔️ GLYPHGUARD ⚔️</h1>
            <p style="font-size: clamp(10px, 1.5vw, 12px); margin-bottom: 30px; max-width: 500px; line-height: 1.6;">
                DEFEND YOUR CASTLE BY TYPING WORDS!<br><br>
                • ONLY 4-8 LETTER WORDS COUNT<br>
                • NO REPEATING WORDS<br>
                • NO PLURALS ALLOWED<br>
                • EACH UNIT TYPE HAS SPECIFIC PATTERNS
            </p>
            <button id="startGameBtn" class="button">START GAME</button>
            <button id="leaderboardBtn" class="button">LEADERBOARD</button>
            <div class="instructions">
                <p>🎮 SPACE/ESC TO PAUSE</p>
                <p>⚔️ START WITH BLOCKERS & SENTRIES</p>
                <p>🏆 SURVIVE WAVES & UNLOCK NEW UNITS</p>
                <p>💡 WAVES LAST 30 SECONDS</p>
            </div>
        </div>
        
        <div id="armoryScreen" class="overlay-screen">
            <h2>⚔️ ARMORY UPGRADES ⚔️</h2>
            <p>CHOOSE YOUR UPGRADE:</p>
            <div class="upgrade-options" id="upgradeOptions">
                <!-- Upgrade cards will be populated here -->
            </div>
            <div style="margin-top: 20px; font-size: clamp(8px, 1vw, 10px); color: #cccccc; font-style: italic;">
                💡 TIP: UNIT REQUIREMENTS ARE RANDOMIZED EACH GAME!
            </div>
        </div>
        
        <div id="gameOverScreen" class="overlay-screen">
            <h2>🏰 CASTLE FALLEN! 🏰</h2>
            <p style="font-size: clamp(12px, 2vw, 16px); margin: 20px 0;">FINAL SCORE: <span id="finalScore" style="color: #ffff44;">0</span></p>
            <p style="font-size: clamp(10px, 1.5vw, 14px); margin: 10px 0;">WAVES: <span id="finalWave" style="color: #44ff44;">0</span></p>
            <div id="nameInput" style="margin: 20px 0;">
                <input type="text" id="playerName" placeholder="ENTER NAME" maxlength="10" style="padding: 8px; margin: 10px; border: 2px solid #00ff41; background: #000000; color: #00ff41; font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 10px; font-weight: bold; text-transform: uppercase;">
                <button onclick="window.saveScore()" class="button">SAVE</button>
            </div>
            <button onclick="window.restartGame()" class="button">PLAY AGAIN</button>
            <button onclick="window.showMainMenu()" class="button">MAIN MENU</button>
        </div>
        
        <div id="leaderboardScreen" class="overlay-screen">
            <h2>🏆 HALL OF HEROES 🏆</h2>
            <div id="leaderboardList" class="leaderboard">
                <!-- Leaderboard entries will be populated here -->
            </div>
            <button onclick="window.showMainMenu()" class="button">BACK</button>
        </div>
        
        <div id="pauseScreen" class="overlay-screen">
            <h2>⏸️ GAME PAUSED</h2>
            <p>PRESS SPACE OR ESC TO RESUME</p>
            <button onclick="window.resumeGame()" class="button">RESUME</button>
            <button onclick="window.showMainMenu()" class="button">MAIN MENU</button>
        </div>
    </div>
    
    <div id="gameUI">
        <div id="gameStats">
            <div class="stat health">❤️ <span id="healthDisplay">10</span></div>
            <div class="stat score">⭐ <span id="scoreDisplay">0</span></div>
            <div class="stat wave">🌊 <span id="waveDisplay">1</span></div>
            <div class="stat enemies">👹 <span id="enemiesDisplay">0</span></div>
            <div class="stat timer">⏰ <span id="timerDisplay">30</span></div>
        </div>
        
        <input type="text" id="wordInput" placeholder="TYPE WORD + ENTER" autocomplete="off" maxlength="8">
        <div id="feedback"></div>
        <button id="helpBtn" class="button" style="margin-bottom:10px;">HELP</button>
    </div>
    
    <div id="unitGuide">
        <h3>📖 UNIT SUMMONING GUIDE:</h3>
        <div id="unitGuideContent">
            <!-- Units will be populated dynamically based on unlocked units -->
        </div>
    </div>
    
    <div id="wordLog">
        <!-- Recent words will appear here -->
    </div>

    <div id="unitInfoModal"></div>

    <div id="helpModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.97); color:#00ff41; border:3px solid #00ff41; border-radius:16px; z-index:3000; padding:32px 40px; max-width:90vw; max-height:80vh; overflow-y:auto; font-family:'Courier New',monospace; font-size:1.1em; box-shadow:0 0 32px #00ff41;">
      <h2 style="color:#00ff41; text-align:center;">HELP & INSTRUCTIONS</h2>
      <p><b>Goal:</b> Defend your base by typing valid words to summon units and defeat waves of enemies!</p>
      <ul>
        <li>Only 4-8 letter words, no plurals, no repeats.</li>
        <li>Each unit type has a unique word pattern (see Unit Guide).</li>
        <li>Unlock new units and upgrades in the Armory every few waves.</li>
        <li>Special upgrades give units new powers (glow = upgraded!).</li>
        <li>Score points for words, kills, and chain bonuses for fast typing.</li>
        <li>Pause: Space/Esc. Leaderboard: Main Menu.</li>
      </ul>
      <h3 style="color:#44ff44;">Unit Types & Upgrades</h3>
      <ul>
        <li><b>Blocker</b>: Tanky melee. <b>Double Summon</b> upgrade.</li>
        <li><b>Sentry</b>: Ranged. <b>Multi-Shot</b> upgrade.</li>
        <li><b>Lancer</b>: Fast melee. <b>Dash Attack</b> upgrade.</li>
        <li><b>Defender</b>: Heavy shield. <b>Shield Wall</b> upgrade.</li>
        <li><b>Buster</b>: Area damage. <b>Explosive Rounds</b> upgrade.</li>
        <li><b>Scripter</b>: Magic/chain. <b>Chain Lightning</b> upgrade.</li>
        <li><b>Patch</b>: Healer. <b>Mass Heal</b> upgrade.</li>
        <li><b>Ping</b>: Fast scout. <b>Speed Boost</b> upgrade.</li>
      </ul>
      <button id="closeHelpBtn" class="button" style="margin-top:18px;">CLOSE</button>
    </div>

    <!-- Version number for debugging -->
    <div id="versionNumber" style="position:fixed; right:32px; bottom:24px; color:#00ff41; font-size:1.1em; font-family:'Courier New',monospace; opacity:0.7; z-index:2000; pointer-events:none; text-shadow:1px 1px 0px #000;">v5.22</div>

    <script>
        // Game constants with responsive sizing - initialize with default values
        let CANVAS_WIDTH = 1200;
        let CANVAS_HEIGHT = 700;
        let BASE_WIDTH = 80;
        
        // Placeholder dictionary - you can replace this with your full dictionary
        let WORD_DICTIONARY = new Set();
        
        // Unit rule variants for randomization - balanced and consistent
        const unitRuleVariants = {
            blocker: [
                {
                    name: "Blocker",
                    requirement: "4+ letters, starts with consonant",
                    check: (word) => word.length >= 4 && word.length <= 8 && !/^[aeiou]/i.test(word)
                },
                {
                    name: "Blocker", 
                    requirement: "4+ letters, contains B, T, or K",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[btk]/i.test(word)
                },
                {
                    name: "Blocker",
                    requirement: "4+ letters, contains R or L", 
                    check: (word) => word.length >= 4 && word.length <= 8 && /[rl]/i.test(word)
                },
                {
                    name: "Blocker",
                    requirement: "4+ letters, contains double consonant",
                    check: (word) => word.length >= 4 && word.length <= 8 && /(bb|cc|dd|ff|gg|hh|jj|kk|ll|mm|nn|pp|qq|rr|ss|tt|vv|ww|xx|zz)/i.test(word)
                },
                {
                    name: "Blocker",
                    requirement: "4+ letters, ends with consonant",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[^aeiou]$/i.test(word)
                },
                {
                    name: "Blocker",
                    requirement: "4+ letters, contains M or N",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[mn]/i.test(word)
                }
            ],
            sentry: [
                {
                    name: "Sentry",
                    requirement: "4+ letters, ends with vowel",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[aeiou]$/i.test(word)
                },
                {
                    name: "Sentry",
                    requirement: "4+ letters, contains A and E",
                    check: (word) => word.length >= 4 && word.length <= 8 && /a/i.test(word) && /e/i.test(word)
                },
                {
                    name: "Sentry", 
                    requirement: "4+ letters, ends with E or A",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[ea]$/i.test(word)
                },
                {
                    name: "Sentry",
                    requirement: "4+ letters, contains I and O",
                    check: (word) => word.length >= 4 && word.length <= 8 && /i/i.test(word) && /o/i.test(word)
                },
                {
                    name: "Sentry",
                    requirement: "4+ letters, starts with vowel",
                    check: (word) => word.length >= 4 && word.length <= 8 && /^[aeiou]/i.test(word)
                },
                {
                    name: "Sentry",
                    requirement: "4+ letters, contains at least 2 vowels",
                    check: (word) => word.length >= 4 && word.length <= 8 && (word.match(/[aeiou]/gi) || []).length >= 2
                }
            ],
            lancer: [
                {
                    name: "Lancer",
                    requirement: "5+ letters, contains C and G",
                    check: (word) => word.length >= 5 && word.length <= 8 && /c/i.test(word) && /g/i.test(word)
                },
                {
                    name: "Lancer",
                    requirement: "5+ letters, has repeated letter",
                    check: (word) => {
                        if (word.length < 5 || word.length > 8) return false;
                        const charCount = {};
                        for (let char of word.toLowerCase()) {
                            charCount[char] = (charCount[char] || 0) + 1;
                            if (charCount[char] >= 2) return true;
                        }
                        return false;
                    }
                },
                {
                    name: "Lancer",
                    requirement: "5+ letters, contains V or Y", 
                    check: (word) => word.length >= 5 && word.length <= 8 && /[vy]/i.test(word)
                },
                {
                    name: "Lancer",
                    requirement: "5+ letters, contains H or S",
                    check: (word) => word.length >= 5 && word.length <= 8 && /[hs]/i.test(word)
                },
                {
                    name: "Lancer",
                    requirement: "5+ letters, ends with Y",
                    check: (word) => word.length >= 5 && word.length <= 8 && /y$/i.test(word)
                },
                {
                    name: "Lancer",
                    requirement: "5+ letters, contains at least 2 pairs of repeated letters",
                    check: (word) => {
                        if (word.length < 5 || word.length > 8) return false;
                        let pairs = 0;
                        for (let i = 1; i < word.length; i++) {
                            if (word[i] === word[i-1]) pairs++;
                        }
                        return pairs >= 2;
                    }
                }
            ],
            defender: [
                {
                    name: "Defender",
                    requirement: "5+ letters, starts with D",
                    check: (word) => word.length >= 5 && word.length <= 8 && /^d/i.test(word)
                },
                {
                    name: "Defender",
                    requirement: "5+ letters, contains D and E",
                    check: (word) => word.length >= 5 && word.length <= 8 && /d/i.test(word) && /e/i.test(word)
                },
                {
                    name: "Defender",
                    requirement: "5+ letters, contains F or P",
                    check: (word) => word.length >= 5 && word.length <= 8 && /[fp]/i.test(word)
                },
                {
                    name: "Defender",
                    requirement: "5+ letters, ends with D or R",
                    check: (word) => word.length >= 5 && word.length <= 8 && /[dr]$/i.test(word)
                },
                {
                    name: "Defender",
                    requirement: "5+ letters, contains B or M",
                    check: (word) => word.length >= 5 && word.length <= 8 && /[bm]/i.test(word)
                },
                {
                    name: "Defender",
                    requirement: "5+ letters, starts and ends with the same letter",
                    check: (word) => word.length >= 5 && word.length <= 8 && word[0].toLowerCase() === word[word.length-1].toLowerCase()
                }
            ],
            buster: [
                {
                    name: "Buster",
                    requirement: "6+ letters, contains X or Z",
                    check: (word) => word.length >= 6 && word.length <= 8 && (/x/i.test(word) || /z/i.test(word))
                },
                {
                    name: "Buster", 
                    requirement: "7+ letters",
                    check: (word) => word.length >= 7 && word.length <= 8
                },
                {
                    name: "Buster",
                    requirement: "6+ letters, contains Q or J",
                    check: (word) => word.length >= 6 && word.length <= 8 && /[qj]/i.test(word)
                },
                {
                    name: "Buster",
                    requirement: "6+ letters, contains W or V",
                    check: (word) => word.length >= 6 && word.length <= 8 && /[wv]/i.test(word)
                },
                {
                    name: "Buster",
                    requirement: "6+ letters, 3 consonants in a row",
                    check: (word) => word.length >= 6 && word.length <= 8 && /[^aeiou]{3}/i.test(word)
                },
                {
                    name: "Buster",
                    requirement: "6+ letters, starts with S or C",
                    check: (word) => word.length >= 6 && word.length <= 8 && /^[sc]/i.test(word)
                }
            ],
            scripter: [
                {
                    name: "Scripter",
                    requirement: "5+ letters, exactly 2 vowels",
                    check: (word) => {
                        if (word.length < 5 || word.length > 8) return false;
                        const vowels = word.toLowerCase().match(/[aeiou]/g);
                        return vowels && vowels.length === 2;
                    }
                },
                {
                    name: "Scripter",
                    requirement: "5+ letters, exactly 3 vowels",
                    check: (word) => {
                        if (word.length < 5 || word.length > 8) return false;
                        const vowels = word.toLowerCase().match(/[aeiou]/g);
                        return vowels && vowels.length === 3;
                    }
                },
                {
                    name: "Scripter", 
                    requirement: "6+ letters, exactly 2 vowels",
                    check: (word) => {
                        if (word.length < 6 || word.length > 8) return false;
                        const vowels = word.toLowerCase().match(/[aeiou]/g);
                        return vowels && vowels.length === 2;
                    }
                },
                {
                    name: "Scripter",
                    requirement: "5+ letters, contains X or Z",
                    check: (word) => word.length >= 5 && word.length <= 8 && /[xz]/i.test(word)
                },
                {
                    name: "Scripter",
                    requirement: "5+ letters, all vowels unique",
                    check: (word) => {
                        if (word.length < 5 || word.length > 8) return false;
                        const vowels = (word.toLowerCase().match(/[aeiou]/g) || []);
                        return new Set(vowels).size === vowels.length;
                    }
                },
                {
                    name: "Scripter",
                    requirement: "6+ letters, contains U or Y",
                    check: (word) => word.length >= 6 && word.length <= 8 && /[uy]/i.test(word)
                }
            ],
            patch: [
                {
                    name: "Patch",
                    requirement: "6+ letters, ends with ING",
                    check: (word) => word.length >= 6 && word.length <= 8 && /ing$/i.test(word)
                },
                {
                    name: "Patch",
                    requirement: "6+ letters, ends with ER or ED",
                    check: (word) => word.length >= 6 && word.length <= 8 && /(er|ed)$/i.test(word)
                },
                {
                    name: "Patch",
                    requirement: "6+ letters, ends with LY or AL",
                    check: (word) => word.length >= 6 && word.length <= 8 && /(ly|al)$/i.test(word)
                },
                {
                    name: "Patch",
                    requirement: "6+ letters, contains TH or SH",
                    check: (word) => word.length >= 6 && word.length <= 8 && /(th|sh)/i.test(word)
                },
                {
                    name: "Patch",
                    requirement: "6+ letters, contains EE or OO",
                    check: (word) => word.length >= 6 && word.length <= 8 && /(ee|oo)/i.test(word)
                },
                {
                    name: "Patch",
                    requirement: "6+ letters, starts with H or L",
                    check: (word) => word.length >= 6 && word.length <= 8 && /^[hl]/i.test(word)
                }
            ],
            ping: [
                {
                    name: "Ping",
                    requirement: "4+ letters, all unique letters",
                    check: (word) => {
                        if (word.length < 4 || word.length > 8) return false;
                        const chars = new Set(word.toLowerCase());
                        return chars.size === word.length;
                    }
                },
                {
                    name: "Ping",
                    requirement: "4+ letters, starts with S or T", 
                    check: (word) => word.length >= 4 && word.length <= 8 && /^[st]/i.test(word)
                },
                {
                    name: "Ping",
                    requirement: "4+ letters, no repeated consonants",
                    check: (word) => {
                        if (word.length < 4 || word.length > 8) return false;
                        const consonants = word.toLowerCase().replace(/[aeiou]/g, '');
                        const uniqueConsonants = new Set(consonants);
                        return uniqueConsonants.size === consonants.length;
                    }
                },
                {
                    name: "Ping",
                    requirement: "4+ letters, contains Q or J",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[qj]/i.test(word)
                },
                {
                    name: "Ping",
                    requirement: "4+ letters, contains at least 3 different vowels",
                    check: (word) => {
                        if (word.length < 4 || word.length > 8) return false;
                        const vowels = (word.toLowerCase().match(/[aeiou]/g) || []);
                        return new Set(vowels).size >= 3;
                    }
                },
                {
                    name: "Ping",
                    requirement: "4+ letters, ends with T or S",
                    check: (word) => word.length >= 4 && word.length <= 8 && /[ts]$/i.test(word)
                }
            ]
        };
        
        // Current active unit rules (randomized each game)
        let activeUnitRules = {};
        
        // Mouse state for tooltips
        let mouseX = 0;
        let mouseY = 0;
        let hoveredUnit = null;
        
        
        // Unit types with base stats - rules are set dynamically
        let unitTypes = {
            blocker: {
                name: "Blocker",
                color: "#ff4444",
                symbol: "🛡️",
                shape: "square",
                health: 3,
                damage: 2,
                speed: 0.4,
                range: 30,
                isMelee: true,
                requirement: "",
                check: null
            },
            sentry: {
                name: "Sentry",
                color: "#44ff44",
                symbol: "📡",
                shape: "triangle",
                health: 2,
                damage: 2,
                speed: 0.25,
                range: 200,
                isMelee: false,
                requirement: "",
                check: null
            },
            lancer: {
                name: "Lancer",
                color: "#ffaa44",
                symbol: "⚡",
                shape: "diamond",
                health: 2,
                damage: 3,
                speed: 0.7,
                range: 35,
                isMelee: true,
                requirement: "",
                check: null
            },
            defender: {
                name: "Defender",
                color: "#8888ff",
                symbol: "🛰️",
                shape: "pentagon",
                health: 6,
                damage: 1,
                speed: 0.15,
                range: 40,
                isMelee: true,
                requirement: "",
                check: null
            },
            buster: {
                name: "Buster",
                color: "#ff44ff",
                symbol: "💥",
                shape: "hexagon",
                health: 2,
                damage: 8,
                speed: 0.1,
                range: 300,
                isMelee: false,
                isAreaDamage: true,
                requirement: "",
                check: null
            },
            scripter: {
                name: "Scripter",
                color: "#aa44ff",
                symbol: "💾",
                shape: "star",
                health: 1,
                damage: 4,
                speed: 0.2,
                range: 180,
                isMelee: false,
                isAreaDamage: true,
                requirement: "",
                check: null
            },
            patch: {
                name: "Patch",
                color: "#44ffaa",
                symbol: "🩹",
                shape: "circle",
                health: 1,
                damage: 0,
                speed: 0.3,
                range: 100,
                isMelee: false,
                isHealer: true,
                requirement: "",
                check: null
            },
            ping: {
                name: "Ping",
                color: "#44aaff",
                symbol: "📶",
                shape: "oval",
                health: 1,
                damage: 1,
                speed: 1.0,
                range: 60,
                isMelee: true,
                requirement: "",
                check: null
            }
        };
        
        // Enemy types with varied difficulty - 8-bit style colors
        const enemyTypes = {
            bug: { health: 6, speed: 0.25, color: "#aa0000", size: 18, reward: 10, name: "Bug" },
            worm: { health: 3, speed: 0.5, color: "#aa4400", size: 14, reward: 15, name: "Worm" },
            bot: { health: 12, speed: 0.15, color: "#333333", size: 24, reward: 25, name: "Bot" },
            swarm: { health: 2, speed: 0.4, color: "#664400", size: 8, reward: 8, name: "Swarm" },
            daemon: { health: 18, speed: 0.2, color: "#440000", size: 26, reward: 50, isElite: true, name: "Daemon" },
            rootkit: { health: 40, speed: 0.1, color: "#000000", size: 35, reward: 100, isBoss: true, name: "Rootkit" },
            drone: { health: 5, speed: 0.22, color: "#44aaff", size: 18, reward: 18, isRanged: true, name: "Drone" }
        };
        
        // Responsive canvas sizing
        function updateCanvasSize() {
            const devicePixelRatio = window.devicePixelRatio || 1;
            
            // Calculate responsive dimensions
            const maxWidth = Math.min(1200, window.innerWidth - 60);
            const maxHeight = Math.min(700, window.innerHeight * 0.5);
            
            CANVAS_WIDTH = maxWidth;
            CANVAS_HEIGHT = maxHeight;
            BASE_WIDTH = Math.max(60, CANVAS_WIDTH * 0.08);
            
            // Set canvas display size
            canvas.style.width = CANVAS_WIDTH + 'px';
            canvas.style.height = CANVAS_HEIGHT + 'px';
            
            // Set actual canvas resolution
            canvas.width = CANVAS_WIDTH * devicePixelRatio;
            canvas.height = CANVAS_HEIGHT * devicePixelRatio;
            
            // Scale the drawing context
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(devicePixelRatio, devicePixelRatio);
            
            console.log(`Canvas resized to: ${CANVAS_WIDTH}x${CANVAS_HEIGHT}`);
        }
        
        // Randomize unit rules for a new game
        function randomizeUnitRules() {
            activeUnitRules = {};
            
            for (let unitType in unitRuleVariants) {
                const variants = unitRuleVariants[unitType];
                const selectedVariant = variants[Math.floor(Math.random() * variants.length)];
                
                activeUnitRules[unitType] = selectedVariant;
                unitTypes[unitType].requirement = selectedVariant.requirement;
                unitTypes[unitType].check = selectedVariant.check;
            }
            
            console.log(`🎲 New ruleset generated!`);
        }
        
        // Particle system for visual effects
        class Particle {
            constructor(x, y, vx, vy, color, life, size = 2) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = size;
                this.gravity = 0.1;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime / 16;
                this.y += this.vy * deltaTime / 16;
                this.vy += this.gravity * deltaTime / 16;
                this.life -= deltaTime;
                return this.life > 0;
            }
            
            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.restore();
            }
        }
        
        // Create particles for visual effects
        function createParticles(x, y, count, color, speed = 1) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const velocity = (2 + Math.random() * 3) * speed;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity - 1;
                const life = 500 + Math.random() * 500;
                const size = 2 + Math.random() * 4;
                
                game.particles.push(new Particle(x, y, vx, vy, color, life, size));
            }
        }
        
        // Screen shake system
        function addScreenShake(intensity, duration) {
            game.camera.shakeIntensity = Math.max(game.camera.shakeIntensity, intensity);
            game.camera.shakeTimer = Math.max(game.camera.shakeTimer, duration);
        }
        
        // Audio feedback (placeholder for 8-bit sounds)
        function playSound(soundName) {
            console.log(`🔊 8-bit sound: ${soundName}`);
            // Future: implement actual 8-bit audio
        }
        
    
        
        function updateWordLogDisplay() {
            const wordLogContainer = document.getElementById('wordLog');
            const now = Date.now();
            
            game.wordLog = game.wordLog.filter(entry => now - entry.timestamp < 20000);
            wordLogContainer.innerHTML = '';
            
            const sortedLog = [...game.wordLog].reverse();
            sortedLog.forEach(entry => {
                const wordDiv = document.createElement('div');
                wordDiv.className = `word-entry ${entry.isSuccess ? 'success' : 'error'}`;
                wordDiv.textContent = entry.word;
                
                const age = now - entry.timestamp;
                const opacity = Math.max(0.2, 1 - (age / 20000) * 0.8);
                wordDiv.style.opacity = opacity;
                
                wordLogContainer.appendChild(wordDiv);
            });
        }
        
        // Game objects
        class Unit {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                
                const baseStats = unitTypes[type];
                const boosts = game.upgrades.statBoosts[type];
                
                this.health = baseStats.health + (boosts ? boosts.health : 0);
                this.maxHealth = this.health;
                this.damage = baseStats.damage + (boosts ? boosts.damage : 0);
                this.speed = baseStats.speed + (boosts ? boosts.speed : 0);
                this.range = baseStats.range;
                this.target = null;
                this.lastAttack = 0;
                this.attackCooldown = 1000;
                if (!baseStats.isMelee && !baseStats.isHealer) {
                    this.attackCooldown = 1800; // slower for ranged
                }
                if (this.type === 'scripter') this.attackCooldown = 2200;
                if (this.type === 'buster') this.attackCooldown = 2500;
                if (this.type === 'patch') this.attackCooldown = 2000;
                if (this.type === 'ping' && !baseStats.isMelee) this.attackCooldown = 1800;
                this.isPlayer = true;
                this.flashTimer = 0;
                this.attackIndicatorTimer = 0;
                this.stunTimer = 0;
            }
            
            update(deltaTime) {
                if (this.stunTimer && this.stunTimer > 0) {
                    this.stunTimer -= deltaTime;
                    return;
                }
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                // Retreat toward halfway point if no enemies
                if (game.enemies.length === 0) {
                    // Retreat to halfway point horizontally
                    const retreatX = CANVAS_WIDTH / 2;
                    if (Math.abs(this.x - retreatX) > 2) {
                        if (this.x > retreatX) {
                            this.x -= this.speed * deltaTime / 16;
                            if (this.x < retreatX) this.x = retreatX;
                        } else {
                            this.x += this.speed * deltaTime / 16;
                            if (this.x > retreatX) this.x = retreatX;
                        }
                    }
                    return;
                }
                
                // Ping Speed Boost
                if (this.type === 'ping' && this.speedBoostTimer && this.speedBoostTimer > 0) {
                    this.speedBoostTimer -= deltaTime;
                    this.speed = unitTypes.ping.speed * 1.5 + (game.upgrades.statBoosts.ping?.speed || 0);
                } else if (this.type === 'ping') {
                    this.speed = unitTypes.ping.speed + (game.upgrades.statBoosts.ping?.speed || 0);
                }

                for (let enemy of game.enemies) {
                    const distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                }
                
                this.target = nearestEnemy;
                
                if (this.target) {
                    if (nearestDistance <= this.range) {
                        const now = Date.now();
                        if (now - this.lastAttack >= this.attackCooldown) {
                            this.attack();
                            this.lastAttack = now;
                        }
                    }
                    
                    if (nearestDistance > this.range) {
                        const dx = this.target.x - this.x;
                        const dy = this.target.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            this.x += (dx / distance) * this.speed * deltaTime / 16;
                            this.y += (dy / distance) * this.speed * deltaTime / 16;
                        }
                    }
                } else {
                    if (this.x < CANVAS_WIDTH - 200) {
                        this.x += this.speed * deltaTime / 16;
                    }
                }
                
                if (unitTypes[this.type].isHealer) {
                    this.healNearbyUnits();
                }

                if (this.type === 'lancer' && game.upgrades.special.lancerDash) {
                    this.dashCooldown = this.dashCooldown ?? 0;
                    this.isDashing = this.isDashing ?? false;
                    this.dashTimer = this.dashTimer ?? 0;
                    this.dashCooldown -= deltaTime;
                    if (!this.isDashing && this.dashCooldown <= 0) {
                        this.isDashing = true;
                        this.dashTimer = 300; // Dash for 300ms
                        this.dashCooldown = 2500 + Math.random() * 1000; // 2.5-3.5s cooldown
                    }
                    if (this.isDashing) {
                        // Move rapidly forward
                        this.x += 3.5 * this.speed * deltaTime / 16;
                        // Check for enemy collision
                        for (let enemy of game.enemies) {
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            if (Math.sqrt(dx*dx + dy*dy) < 24) {
                                enemy.takeDamage(this.damage * 2);
                                createParticles(enemy.x, enemy.y, 12, '#ffaa44', 1.5);
                                addScreenShake(2, 120);
                                this.isDashing = false;
                                break;
                            }
                        }
                        this.dashTimer -= deltaTime;
                        if (this.dashTimer <= 0) this.isDashing = false;
                    }
                }
                        // Prevent overlap with other player units and keep within boundaries
        for (let other of game.units) {
            if (other !== this) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 20) {
                    const overlap = 20 - dist;
                    const nx = dx / (dist || 1);
                    const ny = dy / (dist || 1);
                    this.x -= nx * overlap / 2;
                    this.y -= ny * overlap / 2;
                    other.x += nx * overlap / 2;
                    other.y += ny * overlap / 2;
                }
            }
        }
        
        // Keep units within canvas boundaries
        this.x = Math.max(BASE_WIDTH + 20, Math.min(CANVAS_WIDTH - 20, this.x));
        this.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.y));
            }
            
            attack() {
                if (!this.target) return;
                
                const baseStats = unitTypes[this.type];
                
                if (baseStats.isMelee) {
                    this.target.takeDamage(this.damage);
                    createParticles(this.target.x, this.target.y, 8, "#ffff00", 1.2);
                    playSound('meleeHit');
                    this.target.flashTimer = 100;
                    this.attackIndicatorTimer = 100;
                } else if (!baseStats.isHealer) {
                    if (this.type === 'sentry' && game.upgrades.special.sentryMultiShot) {
                        // Fire 2 projectiles in a reduced spread
                        const angles = [-0.06, 0.06];
                        for (let angle of angles) {
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const baseAngle = Math.atan2(dy, dx);
                            const spreadAngle = baseAngle + angle;
                            const tx = this.x + Math.cos(spreadAngle) * dist;
                            const ty = this.y + Math.sin(spreadAngle) * dist;
                            game.projectiles.push(new Projectile(
                                this.x, this.y, tx, ty,
                                this.damage, unitTypes[this.type].color,
                                baseStats.isAreaDamage, baseStats.isAreaDamage ? 60 : 0,
                                'arrow'
                            ));
                        }
                        playSound('bowShot');
                        this.attackIndicatorTimer = 80;
                    } else {
                        let projType = 'arrow';
                        if (this.type === 'scripter') projType = 'magic';
                        if (this.type === 'buster') projType = 'cannon';
                        let areaRadius = baseStats.isAreaDamage ? 60 : 0;
                        if (this.type === 'buster' && game.upgrades.special.busterExplosive) areaRadius = 100;
                        game.projectiles.push(new Projectile(
                            this.x, this.y, this.target.x, this.target.y,
                            this.damage, unitTypes[this.type].color, 
                            baseStats.isAreaDamage, areaRadius,
                            projType
                        ));
                        playSound(baseStats.isAreaDamage ? 'spellCast' : 'bowShot');
                        this.attackIndicatorTimer = 80;
                    }
                }
            }
            
            healNearbyUnits() {
                for (let unit of game.units) {
                    if (unit !== this && unit.health < unit.maxHealth) {
                        const distance = Math.sqrt((unit.x - this.x) ** 2 + (unit.y - this.y) ** 2);
                        if (distance <= this.range) {
                            unit.health = Math.min(unit.maxHealth, unit.health + 0.02);
                            if (Math.random() < 0.1) {
                                createParticles(unit.x, unit.y, 2, "#00ff00", 0.5);
                            }
                        }
                    }
                }
            }
            
            drawShape(ctx, x, y, size, color, shape) {
                ctx.fillStyle = color;
                ctx.save();
                ctx.translate(x, y);
                
                // All shapes drawn with pixel-perfect squares for 8-bit look
                switch(shape) {
                    case 'square':
                        ctx.fillRect(-size/2, -size/2, size, size);
                        break;
                    case 'triangle':
                        // Pixel triangle
                        for (let i = 0; i < size/2; i++) {
                            ctx.fillRect(-i, size/2 - i * 2, i * 2, 2);
                        }
                        break;
                    case 'diamond':
                        // Pixel diamond
                        for (let i = 0; i < size/2; i++) {
                            ctx.fillRect(-i, -size/2 + i, i * 2, 2);
                            ctx.fillRect(-i, size/2 - i - 2, i * 2, 2);
                        }
                        break;
                    case 'pentagon':
                    case 'hexagon':
                    case 'star':
                        // Simplified to square for 8-bit style
                        ctx.fillRect(-size/2, -size/2, size, size);
                        ctx.fillRect(-size/3, -size/3, size*2/3, size*2/3);
                        break;
                    case 'circle':
                        // Pixel circle
                        const radius = size/2;
                        for (let i = -radius; i <= radius; i += 2) {
                            const width = Math.sqrt(radius * radius - i * i) * 2;
                            ctx.fillRect(-width/2, i, width, 2);
                        }
                        break;
                    case 'oval':
                        // Pixel oval
                        ctx.scale(1.5, 1);
                        const r = size/3;
                        for (let i = -r; i <= r; i += 2) {
                            const w = Math.sqrt(r * r - i * i) * 2;
                            ctx.fillRect(-w/2, i, w, 2);
                        }
                        break;
                    default:
                        ctx.fillRect(-size/2, -size/2, size, size);
                }
                ctx.restore();
            }
            
            draw(ctx) {
                // Shield Wall overlay effect
                if (game.shieldWallTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.45 + 0.25 * Math.abs(Math.sin(Date.now()/180));
                    ctx.shadowColor = '#44ccff';
                    ctx.shadowBlur = 22 + 8 * Math.abs(Math.sin(Date.now()/180));
                    this.drawShape(ctx, this.x, this.y, 32, '#44ccff', unitTypes[this.type].shape);
                    ctx.restore();
                }
                // Glow/pulse for special upgrades
                let special = false;
                let glowColor = unitTypes[this.type].color;
                if (
                    (this.type === 'sentry' && game.upgrades.special.sentryMultiShot) ||
                    (this.type === 'blocker' && game.upgrades.special.blockerDouble) ||
                    (this.type === 'lancer' && game.upgrades.special.lancerDash) ||
                    (this.type === 'defender' && game.upgrades.special.defenderShield) ||
                    (this.type === 'buster' && game.upgrades.special.busterExplosive) ||
                    (this.type === 'scripter' && game.upgrades.special.scripterChain) ||
                    (this.type === 'patch' && game.upgrades.special.patchMassHeal) ||
                    (this.type === 'ping' && game.upgrades.special.pingSpeed)
                ) {
                    special = true;
                }
                if (special) {
                    ctx.save();
                    ctx.globalAlpha = 0.7 + 0.3 * Math.sin(Date.now()/200);
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 6 + 6 * Math.abs(Math.sin(Date.now()/300));
                    this.drawShape(ctx, this.x, this.y, 28, glowColor, unitTypes[this.type].shape);
                    ctx.restore();
                }
                this.drawShape(ctx, this.x, this.y, 20, unitTypes[this.type].color, unitTypes[this.type].shape);
                // Retreating icon
                if (game.enemies.length === 0 && this.x > BASE_WIDTH + 20) {
                    ctx.save();
                    ctx.globalAlpha = 0.85;
                    ctx.font = 'bold 18px Courier New, monospace';
                    ctx.fillStyle = '#44aaff';
                    ctx.textAlign = 'center';
                    ctx.fillText('↩️', this.x, this.y - 24);
                    ctx.restore();
                }
                // 8-bit health bar
                if (this.health < this.maxHealth) {
                    ctx.fillStyle = "#ff0000";
                    ctx.fillRect(this.x - 12, this.y - 16, 24, 4);
                    ctx.fillStyle = "#00ff00";
                    ctx.fillRect(this.x - 12, this.y - 16, 24 * (this.health / this.maxHealth), 4);
                }
                let flash = this.flashTimer && this.flashTimer > 0;
                if (flash) {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = "#ffff00";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 24, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                    this.flashTimer -= 16;
                }
                if (this.attackIndicatorTimer && this.attackIndicatorTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.8 * (this.attackIndicatorTimer / 100);
                    if (unitTypes[this.type].isMelee) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 18, 0, Math.PI * 1.2);
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = '#ffffcc';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 10, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    ctx.restore();
                    this.attackIndicatorTimer -= 16;
                }
                if (this.stunTimer && this.stunTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.9;
                    ctx.font = 'bold 18px Courier New, monospace';
                    ctx.fillStyle = '#ffff00';
                    ctx.textAlign = 'center';
                    ctx.fillText('💫', this.x, this.y - 32);
                    ctx.restore();
                }
            }
        }
        
        class Enemy {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.health = enemyTypes[type].health;
                this.maxHealth = enemyTypes[type].health;
                this.speed = enemyTypes[type].speed;
                this.color = enemyTypes[type].color;
                this.size = enemyTypes[type].size;
                this.reward = enemyTypes[type].reward;
                this.isElite = enemyTypes[type].isElite || false;
                this.isBoss = enemyTypes[type].isBoss || false;
                this.lastDamaged = 0;
                this.flashTimer = 0;
                this.shieldTimer = 0;
                this.dodgeTimer = 0;
                this.dodgeDir = 0;
                this.rangedTimer = 0;
            }
            
            update(deltaTime) {
                this.x -= this.speed * deltaTime / 16;
                
                // Attack nearby units
                let nearestUnit = null;
                let nearestDistance = Infinity;
                
                for (let unit of game.units) {
                    const distance = Math.sqrt((unit.x - this.x) ** 2 + (unit.y - this.y) ** 2);
                    if (distance < nearestDistance && distance <= 40) {
                        nearestDistance = distance;
                        nearestUnit = unit;
                    }
                }
                
                if (nearestUnit && nearestDistance <= 25) {
                    const damage = this.isBoss ? 2 : (this.isElite ? 1.5 : 1);
                    nearestUnit.health -= damage;
                    createParticles(nearestUnit.x, nearestUnit.y, 3, "#ff4444", 0.5);
                }
                
                // Check if reached base
                if (this.x <= BASE_WIDTH) {
                    const baseDamage = this.isBoss ? 3 : (this.isElite ? 2 : 1);
                    game.health -= baseDamage;
                    updateDisplay();
                    
                    addScreenShake(8, 500);
                    createParticles(BASE_WIDTH/2, CANVAS_HEIGHT/2, 20, "#ff0000", 2);
                    playSound('baseDamage');
                    
                    if (game.health <= 0) {
                        this.gameOver();
                    }
                    return true;
                }
                
                if (this.health <= 0) {
                    game.score += this.reward;
                    updateDisplay();
                    
                    createParticles(this.x, this.y, this.isBoss ? 20 : (this.isElite ? 15 : 10), this.color, 1.5);
                    addScreenShake(this.isBoss ? 5 : (this.isElite ? 3 : 1), 200);
                    playSound(this.isBoss ? 'bossDefeat' : 'enemyDefeat');
                    
                    return true;
                }
                
                // Special attacks for Daemon and Rootkit
                if (this.type === 'daemon' && Math.random() < 0.002) {
                    // Stun a random player unit
                    if (game.units.length > 0) {
                        const target = game.units[Math.floor(Math.random() * game.units.length)];
                        target.stunTimer = 1000;
                        createParticles(target.x, target.y, 8, '#ffff00', 1.2);
                        playSound('stun');
                    }
                }
                if (this.type === 'rootkit') {
                    // Occasionally spawn a minion or shield itself
                    if (Math.random() < 0.001) {
                        game.enemies.push(new Enemy(this.x, this.y + 24 - Math.random()*48, 'swarm'));
                        createParticles(this.x, this.y, 10, '#664400', 1.2);
                        playSound('spawn');
                    }
                    if (Math.random() < 0.001) {
                        this.shieldTimer = 1000;
                        createParticles(this.x, this.y, 12, '#44ccff', 1.5);
                        playSound('shield');
                    }
                }
                if (this.shieldTimer && this.shieldTimer > 0) this.shieldTimer -= deltaTime;
                
                // Prevent overlap with other enemy units
                for (let other of game.enemies) {
                    if (other !== this) {
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < this.size) {
                            const overlap = this.size - dist;
                            const nx = dx / (dist || 1);
                            const ny = dy / (dist || 1);
                            this.x -= nx * overlap / 2;
                            this.y -= ny * overlap / 2;
                            other.x += nx * overlap / 2;
                            other.y += ny * overlap / 2;
                        }
                    }
                }
                
                if (this.type === 'worm') {
                    this.dodgeTimer = (this.dodgeTimer || 0) - deltaTime;
                    if (this.dodgeTimer <= 0) {
                        this.dodgeDir = (Math.random() < 0.5 ? -1 : 1) * (8 + Math.random() * 12);
                        this.dodgeTimer = 600 + Math.random() * 800;
                    }
                    this.y += this.dodgeDir * deltaTime / 400;
                }
                
                if (this.type === 'drone') {
                    this.rangedTimer = (this.rangedTimer || 0) - deltaTime;
                    if (this.rangedTimer <= 0 && game.units.length > 0) {
                        const target = game.units[Math.floor(Math.random() * game.units.length)];
                        game.projectiles.push(new Projectile(this.x, this.y, target.x, target.y, 2, this.color, false, 0, 'arrow'));
                        this.rangedTimer = 1800;
                    }
                }
                
                return false;
            }
            
            takeDamage(amount) {
                this.health -= amount;
                this.lastDamaged = Date.now();
                createParticles(this.x, this.y, 8, "#ff4444", 1.2);
                this.flashTimer = 100;
            }
            
            draw(ctx) {
                const flashDuration = 150;
                const timeSinceHit = Date.now() - this.lastDamaged;
                const isFlashing = timeSinceHit < flashDuration;
                
                // Elite/Boss borders - 8-bit style
                if (this.isBoss) {
                    ctx.fillStyle = "#ff0000";
                    ctx.fillRect(this.x - this.size/2 - 4, this.y - this.size/2 - 4, this.size + 8, 4);
                    ctx.fillRect(this.x - this.size/2 - 4, this.y + this.size/2, this.size + 8, 4);
                    ctx.fillRect(this.x - this.size/2 - 4, this.y - this.size/2, 4, this.size);
                    ctx.fillRect(this.x + this.size/2, this.y - this.size/2, 4, this.size);
                }
                
                if (this.isElite) {
                    ctx.fillStyle = "#ffff00";
                    ctx.fillRect(this.x - this.size/2 - 2, this.y - this.size/2 - 2, this.size + 4, 2);
                    ctx.fillRect(this.x - this.size/2 - 2, this.y + this.size/2, this.size + 4, 2);
                    ctx.fillRect(this.x - this.size/2 - 2, this.y - this.size/2, 2, this.size);
                    ctx.fillRect(this.x + this.size/2, this.y - this.size/2, 2, this.size);
                }
                
                ctx.fillStyle = isFlashing ? "#ffffff" : this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                // 8-bit health bar
                if (this.health < this.maxHealth) {
                    ctx.fillStyle = "#ff0000";
                    ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 8, this.size, 4);
                    ctx.fillStyle = "#00ff00";
                    ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 8, this.size * (this.health / this.maxHealth), 4);
                }
                let flash = this.flashTimer && this.flashTimer > 0;
                if (flash) {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = "#ff4444";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 24, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                    this.flashTimer -= 16;
                }
                if (this.shieldTimer && this.shieldTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + 0.3 * Math.abs(Math.sin(Date.now()/120));
                    ctx.strokeStyle = '#44ccff';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2 + 10, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        
        class Projectile {
            constructor(startX, startY, targetX, targetY, damage, color, isAreaDamage = false, areaRadius = 0, projType = 'arrow') {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.damage = damage;
                this.color = color;
                this.speed = 5; // was 4, now slightly faster
                this.isAreaDamage = isAreaDamage;
                this.areaRadius = areaRadius;
                this.projType = projType;
                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime / 16;
                this.y += this.vy * deltaTime / 16;

                if (this.projType === 'magic' && game.upgrades.special.scripterChain) {
                    // Chain lightning logic
                    let hitEnemies = [];
                    let currentX = this.x;
                    let currentY = this.y;
                    let remainingChains = 3;
                    while (remainingChains > 0) {
                        let nearest = null;
                        let nearestDist = Infinity;
                        for (let enemy of game.enemies) {
                            if (hitEnemies.includes(enemy)) continue;
                            const dist = Math.sqrt((enemy.x - currentX) ** 2 + (enemy.y - currentY) ** 2);
                            if (dist < nearestDist && dist < 80) {
                                nearest = enemy;
                                nearestDist = dist;
                            }
                        }
                        if (!nearest) break;
                        nearest.takeDamage(this.damage);
                        createParticles(nearest.x, nearest.y, 8, this.color, 1.2);
                        hitEnemies.push(nearest);
                        currentX = nearest.x;
                        currentY = nearest.y;
                        remainingChains--;
                    }
                    playSound('spellCast');
                    return true;
                }
                
                for (let enemy of game.enemies) {
                    const distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (distance < 15) {
                        if (this.isAreaDamage) {
                            this.dealAreaDamage();
                            playSound('explosion');
                        } else {
                            enemy.takeDamage(this.damage);
                            playSound('projectileHit');
                        }
                        return true;
                    }
                }
                
                return this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT;
            }
            
            dealAreaDamage() {
                let hitCount = 0;
                for (let enemy of game.enemies) {
                    const distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (distance <= this.areaRadius) {
                        const damageMultiplier = 1 - (distance / this.areaRadius) * 0.5;
                        const finalDamage = Math.ceil(this.damage * damageMultiplier);
                        enemy.takeDamage(finalDamage);
                        hitCount++;
                    }
                }
                
                game.explosions = game.explosions || [];
                game.explosions.push({
                    x: this.x,
                    y: this.y,
                    radius: this.areaRadius,
                    timer: 300,
                    color: this.color
                });
                
                createParticles(this.x, this.y, 15 + hitCount * 3, this.color, 2);
                addScreenShake(3 + hitCount, 250);
            }
            
            draw(ctx) {
                if (this.projType === 'arrow') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(Math.atan2(this.vy, this.vx));
                    ctx.fillStyle = '#ffffcc';
                    ctx.fillRect(-6, -1.5, 9, 3); // was -8, -2, 12, 4
                    ctx.beginPath();
                    ctx.moveTo(3, -4); ctx.lineTo(9, 0); ctx.lineTo(3, 4); ctx.closePath(); // was 4, -5, 12, 0, 4, 5
                    ctx.fillStyle = '#ffaa00';
                    ctx.fill();
                    ctx.restore();
                } else if (this.projType === 'magic') {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.shadowColor = '#aa44ff';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#aa44ff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 6, 0, 2 * Math.PI); // was 8
                    ctx.fill();
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(this.x - this.vx*2, this.y - this.vy*2, 9, 0, 2 * Math.PI); // was 12
                    ctx.fill();
                    ctx.restore();
                } else if (this.projType === 'cannon') {
                    ctx.save();
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 7, 0, 2 * Math.PI); // was 10
                    ctx.fill();
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 10, 0, 2 * Math.PI); // was 14
                    ctx.stroke();
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.fillStyle = this.color || '#ffffff';
                    ctx.fillRect(this.x - 1.5, this.y - 1.5, 3, 3); // was 4x4
                    ctx.restore();
                }
            }
        }
        
        // Initialize game
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const wordInput = document.getElementById('wordInput');
        const feedback = document.getElementById('feedback');
        
        // Initialize canvas size immediately
        updateCanvasSize();
        
        // Add responsive behavior with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateCanvasSize();
                console.log('Window resized, canvas updated');
            }, 100);
        });
        
        // Add orientation change listener for mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateCanvasSize();
                console.log('Orientation changed, canvas updated');
            }, 200);
        });
        

        function gameLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (!game.isGameOver && !game.isPaused && !game.isMainMenu) {
                game.update(deltaTime);
            }
            
            game.draw();
            requestAnimationFrame(gameLoop);
        }
        
        
        
        function checkForHint() {
            if (game.invalidWordCount >= 5) {
                const hint = generateWordHint();
                if (hint) {
                    showFeedback(`💡 HINT: TRY "${hint.toUpperCase()}"`, 'success');
                    game.invalidWordCount = 0;
                }
            }
        }
        
        function generateWordHint() {
            const availableWords = Array.from(WORD_DICTIONARY).filter(word => 
                !game.usedWords.has(word) && 
                word.length >= 4 && word.length <= 8 &&
                !word.endsWith('s') &&
                Object.entries(unitTypes).some(([unitType, unitData]) => 
                    game.unlockedUnits.has(unitType) && unitData.check(word))
            );
            
            if (availableWords.length === 0) return null;
            
            // Sort by simplicity (shorter words first)
            availableWords.sort((a, b) => a.length - b.length);
            
            return availableWords[0];
        }
        
        function showFeedback(message, type) {
            feedback.textContent = message;
            feedback.className = type;
            setTimeout(() => {
                feedback.textContent = '';
                feedback.className = '';
            }, 3000);
        }
        
        function updateDisplay() {
            document.getElementById('healthDisplay').textContent = game.health;
            document.getElementById('scoreDisplay').textContent = game.score;
            document.getElementById('waveDisplay').textContent = game.wave;
            document.getElementById('enemiesDisplay').textContent = game.enemiesRemaining;
            document.getElementById('timerDisplay').textContent = game.waveTimeLeft;
            document.getElementById('scoreAboveTitle').textContent = `SCORE: ${game.score}`;
        }
        
        
        
        function getAvailableUpgrades() {
            const available = [];
            
            // Unit unlocks - prioritize these early in the game
            const allUnits = ['lancer', 'defender', 'buster', 'scripter', 'patch', 'ping'];
            const lockedUnits = allUnits.filter(unit => !game.unlockedUnits.has(unit));
            
            lockedUnits.forEach(unitType => {
                available.push({
                    name: `UNLOCK: ${unitTypes[unitType].name.toUpperCase()}`,
                    description: `UNLOCK ${unitTypes[unitType].name.toUpperCase()} UNITS! ${getUnitDescription(unitType)}`,
                    stats: "NEW UNIT TYPE",
                    type: 'unlock',
                    unitType: unitType,
                    apply: () => {
                        game.unlockedUnits.add(unitType);
                        updateUnitGuide();
                    }
                });
            });
            
            // Stat upgrades for unlocked unit types only
            for (let unitType of game.unlockedUnits) {
                available.push({
                    name: `${unitTypes[unitType].name.toUpperCase()} BOOST`,
                    description: `ENHANCE ALL ${unitTypes[unitType].name.toUpperCase()} UNITS WITH BETTER STATS.`,
                    stats: "+1 HEALTH, +1 DAMAGE, +20% SPEED",
                    type: 'stat',
                    unitType: unitType,
                    apply: () => {
                        game.upgrades.statBoosts[unitType].health += 1;
                        game.upgrades.statBoosts[unitType].damage += 1;
                        game.upgrades.statBoosts[unitType].speed += unitTypes[unitType].speed * 0.2;
                    }
                });
            }
            
            // Special upgrades
            available.push({
                name: "CASTLE FORTIFICATION",
                description: "STRENGTHEN YOUR CASTLE WALLS TO WITHSTAND MORE DAMAGE.",
                stats: "+3 HEALTH",
                type: 'castle',
                apply: () => { game.health += 3; updateDisplay(); }
            });
            
            available.push({
                name: "BATTLE TRAINING",
                description: "ALL YOUR UNITS BECOME MORE EXPERIENCED IN COMBAT.",
                stats: "ALL UNITS +1 DAMAGE",
                type: 'global',
                apply: () => {
                    for (let unitType of game.unlockedUnits) {
                        game.upgrades.statBoosts[unitType].damage += 1;
                    }
                }
            });
            
            // Sentry multi-shot
            if (!game.upgrades.special.sentryMultiShot && game.unlockedUnits.has('sentry')) {
                available.push({
                    name: 'SENTRY MULTI-SHOT',
                    description: 'SENTRY FIRES 3 PROJECTILES IN A SPREAD.',
                    stats: 'SENTRY: MULTI-PROJECTILE',
                    type: 'special',
                    apply: () => { game.upgrades.special.sentryMultiShot = true; }
                });
            }
            // Blocker double
            if (!game.upgrades.special.blockerDouble && game.unlockedUnits.has('blocker')) {
                available.push({
                    name: 'BLOCKER DOUBLE SUMMON',
                    description: 'SUMMON 2 BLOCKERS PER VALID WORD.',
                    stats: 'BLOCKER: DOUBLE UNIT',
                    type: 'special',
                    apply: () => { game.upgrades.special.blockerDouble = true; }
                });
            }
            // Lancer dash
            if (!game.upgrades.special.lancerDash && game.unlockedUnits.has('lancer')) {
                available.push({
                    name: 'LANCER DASH',
                    description: 'LANCERS PERIODICALLY DASH THROUGH ENEMIES FOR EXTRA DAMAGE.',
                    stats: 'LANCER: DASH ATTACK',
                    type: 'special',
                    apply: () => { game.upgrades.special.lancerDash = true; }
                });
            }
            // Defender shield
            if (!game.upgrades.special.defenderShield && game.unlockedUnits.has('defender')) {
                available.push({
                    name: 'DEFENDER SHIELD WALL',
                    description: 'DEFENDERS REDUCE DAMAGE TAKEN BY ALL UNITS FOR 5S AFTER SUMMON.',
                    stats: 'DEFENDER: SHIELD WALL',
                    type: 'special',
                    apply: () => { game.upgrades.special.defenderShield = true; }
                });
            }
            // Buster explosive
            if (!game.upgrades.special.busterExplosive && game.unlockedUnits.has('buster')) {
                available.push({
                    name: 'BUSTER EXPLOSIVE ROUNDS',
                    description: 'BUSTER AREA DAMAGE RADIUS INCREASED.',
                    stats: 'BUSTER: BIGGER EXPLOSIONS',
                    type: 'special',
                    apply: () => { game.upgrades.special.busterExplosive = true; }
                });
            }
            // Scripter chain
            if (!game.upgrades.special.scripterChain && game.unlockedUnits.has('scripter')) {
                available.push({
                    name: 'SCRIPTER CHAIN LIGHTNING',
                    description: 'SCRIPTER PROJECTILES CAN HIT MULTIPLE ENEMIES.',
                    stats: 'SCRIPTER: CHAIN ATTACK',
                    type: 'special',
                    apply: () => { game.upgrades.special.scripterChain = true; }
                });
            }
            // Patch mass heal
            if (!game.upgrades.special.patchMassHeal && game.unlockedUnits.has('patch')) {
                available.push({
                    name: 'PATCH MASS HEAL',
                    description: 'PATCH HEALS ALL UNITS SLIGHTLY ON SUMMON.',
                    stats: 'PATCH: MASS HEAL',
                    type: 'special',
                    apply: () => { game.upgrades.special.patchMassHeal = true; }
                });
            }
            // Ping speed
            if (!game.upgrades.special.pingSpeed && game.unlockedUnits.has('ping')) {
                available.push({
                    name: 'PING SPEED BOOST',
                    description: 'PINGS MOVE 50% FASTER FOR 5S AFTER SPAWN.',
                    stats: 'PING: SPEED BOOST',
                    type: 'special',
                    apply: () => { game.upgrades.special.pingSpeed = true; }
                });
            }
            
            return available;
        }
        
        function getUnitDescription(unitType) {
            const descriptions = {
                lancer: "FAST CYBER-LANCERS FOR LIGHTNING STRIKES.",
                defender: "HEAVY SHIELD UNITS WITH HIGH HEALTH.",
                buster: "LONG-RANGE BUSTERS WITH AREA DAMAGE.",
                scripter: "SCRIPTING HACKERS WITH SPECIAL ATTACKS.",
                patch: "SUPPORT PATCH UNITS THAT HEAL ALLIES.",
                ping: "ULTRA-FAST PING UNITS FOR RAPID RESPONSE."
            };
            return descriptions[unitType] || "A POWERFUL NEW UNIT TYPE.";
        }
        
        function updateUnitGuide() {
            const unitGuideContent = document.getElementById('unitGuideContent');
            if (!unitGuideContent) return;
            
            unitGuideContent.innerHTML = '';
            
            // Only show unlocked units with their current requirements
            for (let [unitType, unitData] of Object.entries(unitTypes)) {
                if (game.unlockedUnits.has(unitType)) {
                    const unitDiv = document.createElement('div');
                    unitDiv.className = 'unit-type';
                    unitDiv.innerHTML = `${unitData.symbol} ${unitData.name.toUpperCase()}: ${unitData.requirement.toUpperCase()}`;
                    unitGuideContent.appendChild(unitDiv);
                }
            }
            
            // Show helpful message if only starting units are unlocked
            if (game.unlockedUnits.size === 2) {
                const hintDiv = document.createElement('div');
                hintDiv.style.fontStyle = 'italic';
                hintDiv.style.color = '#cccccc';
                hintDiv.style.fontSize = 'clamp(8px, 1vw, 10px)';
                hintDiv.style.marginTop = '10px';
                hintDiv.innerHTML = '💡 UNLOCK MORE UNITS IN THE ARMORY!';
                unitGuideContent.appendChild(hintDiv);
            }
        }
        
        
        
        
        
        // Define global game functions first
        window.startGame = function() {
            console.log('startGame() function called!');
            console.log('Game state reset');
            game.isMainMenu = false; // <-- Ensure the game leaves the main menu state
            // Randomize unit rules for new game
            randomizeUnitRules();
            updateUnitGuide();
            // Hide main menu
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.style.display = 'none';
                console.log('Main menu hidden');
            }
            // Update display and focus input
            updateDisplay();
            const wordInput = document.getElementById('wordInput');
            if (wordInput) {
                wordInput.value = '';
                setTimeout(() => {
                    wordInput.focus();
                    console.log('Word input focused');
                }, 100);
            }
            showFeedback("DEFEND YOUR CASTLE! TYPE WORDS TO SUMMON UNITS!", 'success');
            console.log('Game started successfully!');
        };
        
        window.showLeaderboard = function() {
            console.log('showLeaderboard() called');
            const leaderboard = getLeaderboard();
            const leaderboardList = document.getElementById('leaderboardList');
            
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<p>NO SCORES YET! BE THE FIRST HERO!</p>';
            } else {
                let html = '<table style="width: 100%; border-collapse: collapse;">';
                html += '<tr style="border-bottom: 2px solid #00ff41;"><th>RANK</th><th>NAME</th><th>SCORE</th><th>WAVE</th><th>DATE</th></tr>';
                
                leaderboard.forEach((entry, index) => {
                    const rankEmoji = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                    html += `<tr style="border-bottom: 1px solid #00ff41;">
                        <td style="padding: 8px; text-align: center;">${rankEmoji}</td>
                        <td style="padding: 8px;">${entry.name}</td>
                        <td style="padding: 8px; text-align: right; color: #ffff44;">${entry.score}</td>
                        <td style="padding: 8px; text-align: center; color: #44ff44;">${entry.wave}</td>
                        <td style="padding: 8px; text-align: center; color: #cccccc;">${entry.date}</td>
                    </tr>`;
                });
                html += '</table>';
                leaderboardList.innerHTML = html;
            }
            
            document.getElementById('leaderboardScreen').style.display = 'block';
        };
        
        window.saveScore = function() {
            const playerName = document.getElementById('playerName').value.trim() || 'ANONYMOUS';
            const leaderboard = getLeaderboard();
            
            leaderboard.push({
                name: playerName.substring(0, 10).toUpperCase(),
                score: game.score,
                wave: game.wave,
                date: new Date().toLocaleDateString()
            });
            
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard.splice(10);
            
            saveLeaderboard(leaderboard);
            document.getElementById('nameInput').style.display = 'none';
            showFeedback('SCORE SAVED!', 'success');
        };
        
        window.restartGame = function() {
            window.startGame();
            document.getElementById('gameOverScreen').style.display = 'none';
        };
        
        window.showMainMenu = function() {
            console.log('Showing main menu...');
            game.isMainMenu = true;
            game.isPaused = false;
            
            // Hide all other screens
            const screens = ['gameOverScreen', 'pauseScreen', 'leaderboardScreen', 'armoryScreen'];
            screens.forEach(screenId => {
                const screen = document.getElementById(screenId);
                if (screen) screen.style.display = 'none';
            });
            
            // Show main menu
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.style.display = 'block';
                console.log('Main menu displayed');
            } else {
                console.error('Main menu element not found!');
            }
        };
        
        window.resumeGame = function() {
            game.isPaused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            const wordInput = document.getElementById('wordInput');
            if (wordInput) wordInput.focus();
        };
        
        function showMainMenu() {
            console.log('Showing main menu...');
            game.isMainMenu = true;
            game.isPaused = false;
            
            // Hide all other screens
            const screens = ['gameOverScreen', 'pauseScreen', 'leaderboardScreen', 'armoryScreen'];
            screens.forEach(screenId => {
                const screen = document.getElementById(screenId);
                if (screen) screen.style.display = 'none';
            });
            
            // Show main menu
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.style.display = 'block';
                console.log('Main menu displayed');
            } else {
                console.error('Main menu element not found!');
            }
        }
        
        function pauseGame() {
            if (!game.isMainMenu && !game.isGameOver) {
                game.isPaused = !game.isPaused;
                document.getElementById('pauseScreen').style.display = game.isPaused ? 'block' : 'none';
                if (!game.isPaused) {
                    wordInput.focus();
                }
            }
        }
        
        function resumeGame() {
            game.isPaused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            wordInput.focus();
        }
        
        function restartGame() {
            startGame();
            document.getElementById('gameOverScreen').style.display = 'none';
        }
        
        // Leaderboard system
        function getLeaderboard() {
            const stored = localStorage.getItem('glyphguardLeaderboard');
            return stored ? JSON.parse(stored) : [];
        }
        
        function saveLeaderboard(leaderboard) {
            localStorage.setItem('glyphguardLeaderboard', JSON.stringify(leaderboard));
        }
        
        function saveScore() {
            const playerName = document.getElementById('playerName').value.trim() || 'ANONYMOUS';
            const leaderboard = getLeaderboard();
            
            leaderboard.push({
                name: playerName.substring(0, 10).toUpperCase(),
                score: game.score,
                wave: game.wave,
                date: new Date().toLocaleDateString()
            });
            
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard.splice(10);
            
            saveLeaderboard(leaderboard);
            document.getElementById('nameInput').style.display = 'none';
            showFeedback('SCORE SAVED!', 'success');
        }
        
        function showLeaderboard() {
            const leaderboard = getLeaderboard();
            const leaderboardList = document.getElementById('leaderboardList');
            
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<p>NO SCORES YET! BE THE FIRST HERO!</p>';
            } else {
                let html = '<table style="width: 100%; border-collapse: collapse;">';
                html += '<tr style="border-bottom: 2px solid #00ff41;"><th>RANK</th><th>NAME</th><th>SCORE</th><th>WAVE</th><th>DATE</th></tr>';
                
                leaderboard.forEach((entry, index) => {
                    const rankEmoji = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                    html += `<tr style="border-bottom: 1px solid #00ff41;">
                        <td style="padding: 8px; text-align: center;">${rankEmoji}</td>
                        <td style="padding: 8px;">${entry.name}</td>
                        <td style="padding: 8px; text-align: right; color: #ffff44;">${entry.score}</td>
                        <td style="padding: 8px; text-align: center; color: #44ff44;">${entry.wave}</td>
                        <td style="padding: 8px; text-align: center; color: #cccccc;">${entry.date}</td>
                    </tr>`;
                });
                html += '</table>';
                leaderboardList.innerHTML = html;
            }
            
            document.getElementById('leaderboardScreen').style.display = 'block';
        }
        
        // Event listeners
        wordInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter' && !game.isMainMenu && !game.isGameOver && !game.isPaused) {
        game.processWord(this.value);
                this.value = '';
            }
        });
        
        wordInput.addEventListener('input', function(e) {
            // Convert to lowercase and limit to 8 characters, only letters
            this.value = this.value.toLowerCase().replace(/[^a-z]/g, '').substring(0, 8);
        });
        
        document.addEventListener('keydown', function(e) {
            if ((e.key === ' ' || e.key === 'Escape') && !game.isMainMenu) {
                e.preventDefault();
                pauseGame();
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width);
            mouseY = (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height);
            hoveredUnit = null;
            for (let unit of game.units) {
                const dx = unit.x - mouseX;
                const dy = unit.y - mouseY;
                if (Math.sqrt(dx*dx + dy*dy) < 18) {
                    hoveredUnit = unit;
                    break;
                }
            }
            if (!hoveredUnit) {
                for (let enemy of game.enemies) {
                    const dx = enemy.x - mouseX;
                    const dy = enemy.y - mouseY;
                    if (Math.sqrt(dx*dx + dy*dy) < enemy.size/2 + 4) {
                        hoveredUnit = enemy;
                        break;
                    }
                }
            }
            const modal = document.getElementById('unitInfoModal');
            if (hoveredUnit) {
                modal.style.display = 'block';
                let info = '';
                if (hoveredUnit.type) {
                    info += `<b>${unitTypes[hoveredUnit.type]?.name || hoveredUnit.type}</b><br>`;
                    info += `Health: ${Math.round(hoveredUnit.health)}/${Math.round(hoveredUnit.maxHealth)}<br>`;
                    info += `Damage: ${hoveredUnit.damage ?? '-'}<br>`;
                } else {
                    info += `<b>ENEMY</b><br>`;
                    info += `Health: ${Math.round(hoveredUnit.health)}/${Math.round(hoveredUnit.maxHealth)}<br>`;
                    info += `Damage: ${hoveredUnit.isBoss ? 3 : (hoveredUnit.isElite ? 1.5 : 1)}<br>`;
                }
                modal.innerHTML = info;
                let px = e.clientX + 18;
                let py = e.clientY + 8;
                modal.style.left = px + 'px';
                modal.style.top = py + 'px';
            } else {
                modal.style.display = 'none';
            }
        });
        canvas.addEventListener('mouseleave', function() {
            document.getElementById('unitInfoModal').style.display = 'none';
        });
        
        // Button event listeners - using the global functions
        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            const startBtn = document.getElementById('startGameBtn');
            const leaderboardBtn = document.getElementById('leaderboardBtn');
            
            if (startBtn) {
                console.log('Found start button, setting up event listener');
                startBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Start game button clicked!');
                    window.startGame();
                });
                console.log('Start button event listener set up successfully');
            } else {
                console.error('Could not find start button element!');
            }
            
            if (leaderboardBtn) {
                console.log('Found leaderboard button, setting up event listener');
                leaderboardBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Leaderboard button clicked!');
                    window.showLeaderboard();
                });
                console.log('Leaderboard button event listener set up successfully');
            } else {
                console.error('Could not find leaderboard button element!');
            }
        }
        
        // Initialize game on page load with multiple safety checks
        function initializeGame() {
            console.log('Initializing GlyphGuard...');
            
            // Double-check that essential elements exist
            const canvas = document.getElementById('gameCanvas');
            const startBtn = document.getElementById('startGameBtn');
            const wordInput = document.getElementById('wordInput');
            
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            if (!startBtn) {
                console.error('Start button element not found!');
                return;
            }
            
            if (!wordInput) {
                console.error('Word input element not found!');
                return;
            }
            
            console.log('All essential elements found');
            
            // Set up event listeners with a slight delay to ensure DOM is ready
            setTimeout(() => {
                setupEventListeners();
            }, 100);
            
            // Randomize unit rules for the first time
            randomizeUnitRules();
            updateUnitGuide();
            updateDisplay();
            
            // Show main menu using the global function
            window.showMainMenu();
            
            // Start game loop
            console.log('Starting game loop...');
            requestAnimationFrame(gameLoop);
            
            console.log('GlyphGuard initialized successfully!');
        }
        
        // Multiple initialization methods for maximum compatibility
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else if (document.readyState === 'interactive' || document.readyState === 'complete') {
            // DOM is already ready
            setTimeout(initializeGame, 50);
        } else {
            // Fallback
            window.addEventListener('load', initializeGame);
        }

        // The following is a high-level summary of the changes to be made. The actual code will be updated throughout the file.

        // 1. Add a script to load the dictionary from filtered_collins_2019_unit_rules.txt
        async function loadDictionary(url) {
            const response = await fetch(url);
            const text = await response.text();
            // Normalize: lowercase and trim each word
            return new Set(text.trim().split(',').map(w => w.trim().toLowerCase()).filter(Boolean));
        }
        loadDictionary('filtered_collins_2019_unit_rules.txt').then(dict => {
            WORD_DICTIONARY = dict;
            console.log('Dictionary loaded:', WORD_DICTIONARY.size, 'words');
        });

        // 2. Refactor word validation logic
        function isPlural(word) {
            if (word.length <= 4) return false;
            if (word.endsWith('ies') && word.length > 5) return true;
            if (word.endsWith('es') && word.length > 5) return true;
            if (word.endsWith('s') && word.length > 4) return true;
            return false;
        }
        function validateWord(word, usedWords, dictionary) {
            if (word.length < 4 || word.length > 8) return { valid: false, reason: 'length' };
            if (isPlural(word)) return { valid: false, reason: 'plural' };
            if (usedWords.has(word)) return { valid: false, reason: 'repeat' };
            if (!dictionary.has(word)) return { valid: false, reason: 'not_in_dict' };
            return { valid: true };
        }


        // 4. Refactor long functions (update, draw, etc.) into smaller helpers
        // 5. Encapsulate game state and logic in a Game class
        // 6. Add ARIA labels and keyboard navigation for overlays
        // 7. Make feedback messages more visually distinct
        // 8. Add comments and improve code readability

        // The above are high-level summaries. The actual code will be updated throughout the file to implement these improvements.

        // The rest of the code will be updated accordingly.

        // Encapsulate all game state into a single GlyphGuardGame class
        class GlyphGuardGame {
            constructor() {
                this.health = 10;
                this.score = 0;
                this.wave = 1;
                this.isGameOver = false;
                this.isPaused = false;
                this.isArmoryOpen = false;
                this.isMainMenu = true;
                this.usedWords = new Set();
                this.invalidWordCount = 0;
                this.consecutiveSuccesses = 0;
                this.units = [];
                this.enemies = [];
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.tracks = 2;
                this.waveTimer = 0;
                this.waveTimeLeft = 30;
                this.nextEnemySpawn = 0;
                this.enemySpawnRate = 5000;
                this.unlockedUnits = new Set(['blocker', 'sentry']);
                this.enemiesThisWave = 0;
                this.enemiesRemaining = 0;
                this.wordLog = [];
                this.camera = {
                    zoom: 1.0,
                    targetZoom: 1.0,
                    shakeX: 0,
                    shakeY: 0,
                    shakeIntensity: 0,
                    shakeTimer: 0
                };
                this.upgrades = {
                    statBoosts: {
                        blocker: { health: 0, damage: 0, speed: 0 },
                        sentry: { health: 0, damage: 0, speed: 0 },
                        lancer: { health: 0, damage: 0, speed: 0 },
                        defender: { health: 0, damage: 0, speed: 0 },
                        buster: { health: 0, damage: 0, speed: 0 },
                        scripter: { health: 0, damage: 0, speed: 0 },
                        patch: { health: 0, damage: 0, speed: 0 },
                        ping: { health: 0, damage: 0, speed: 0 }
                    },
                    evolutions: {},
                    special: {
                        sentryMultiShot: false,
                        blockerDouble: false,
                        lancerDash: false,
                        defenderShield: false,
                        busterExplosive: false,
                        scripterChain: false,
                        patchMassHeal: false,
                        pingSpeed: false
                    }
                };
                this.activeUnitRules = {};
                // ... any other state ...
                this.shieldWallTimer = 0;
                this.lastSuccessTime = 0;
                this.chainCount = 0;
            }
            processWord(word) {
                word = word.toLowerCase().trim();
                if (!word) return;
                const result = validateWord(word, this.usedWords, WORD_DICTIONARY);
                if (!result.valid) {
                    this.invalidWordCount++;
                    this.consecutiveSuccesses = 0;
                    this.addToWordLog(word, false);
                    let feedbackMsg = '';
                    let feedbackType = 'error';
                    switch (result.reason) {
                        case 'length':
                            feedbackMsg = 'WORDS MUST BE 4-8 LETTERS!';
                            break;
                        case 'plural':
                            feedbackMsg = 'NO PLURALS ALLOWED!';
                            break;
                        case 'repeat':
                            feedbackMsg = 'WORD ALREADY USED!';
                            break;
                        case 'not_in_dict':
                            feedbackMsg = 'INVALID WORD!';
                            break;
                    }
                    showFeedback(feedbackMsg, feedbackType);
                    wordInput.classList.add('invalid');
                    setTimeout(() => wordInput.classList.remove('invalid'), 500);
                    playSound('wordError');
                    this.checkForHint();
                    return;
                }
                // ... existing success logic, replacing game. with this ...
                const now = Date.now();
                if (now - this.lastSuccessTime <= 2000) {
                    this.chainCount++;
                    const chainBonus = 20 * this.chainCount;
                    this.score += chainBonus;
                    showFeedback(`CHAIN BONUS! +${chainBonus}`, 'success');
                } else {
                    this.chainCount = 0;
                }
                this.lastSuccessTime = now;
            }
            update(deltaTime) {
                if (this.isArmoryOpen) return;

                this.waveTimer += deltaTime;

                // Update wave timer display (30 seconds per wave)
                this.waveTimeLeft = Math.max(0, 30 - Math.floor(this.waveTimer / 1000));

                // Update word log display
                updateWordLogDisplay();

                // Camera zoom based on track count
                const maxTracks = 8;
                if (this.tracks <= maxTracks) {
                    this.camera.targetZoom = Math.max(0.6, 1.0 - (this.tracks - 2) * 0.05);
                }

                this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.02;

                // Update screen shake
                if (this.camera.shakeTimer > 0) {
                    this.camera.shakeTimer -= deltaTime;
                    const shakeAmount = this.camera.shakeIntensity * (this.camera.shakeTimer / 500);
                    this.camera.shakeX = (Math.random() - 0.5) * shakeAmount;
                    this.camera.shakeY = (Math.random() - 0.5) * shakeAmount;
                } else {
                    this.camera.shakeX = 0;
                    this.camera.shakeY = 0;
                    this.camera.shakeIntensity = 0;
                }

                // Spawn enemies every 5 seconds initially, accelerating
                if (this.waveTimer >= this.nextEnemySpawn) {
                    this.spawnEnemy();
                    // Accelerate spawn rate as wave progresses
                    const waveProgress = this.waveTimer / 30000;
                    const baseRate = 5000;
                    const acceleratedRate = baseRate * (1 - waveProgress * 0.7);
                    this.nextEnemySpawn = this.waveTimer + Math.max(1000, acceleratedRate);
                }

                // Update game objects
                this.units = this.units.filter(unit => {
                    unit.update(deltaTime);
                    return unit.health > 0;
                });

                this.enemies = this.enemies.filter(enemy => {
                    const shouldRemove = enemy.update(deltaTime);
                    if (shouldRemove) {
                        this.enemiesRemaining = Math.max(0, this.enemiesRemaining - 1);
                    }
                    return !shouldRemove;
                });

                this.projectiles = this.projectiles.filter(projectile => {
                    return !projectile.update(deltaTime);
                });

                this.particles = this.particles.filter(particle => {
                    return particle.update(deltaTime);
                });

                if (this.explosions) {
                    this.explosions = this.explosions.filter(explosion => {
                        explosion.timer -= deltaTime;
                        return explosion.timer > 0;
                    });
                }

                updateDisplay();

                // Wave progression - exactly 30 seconds
                if (this.waveTimer >= 30000) {
                    this.nextWave();
                }

                if (this.shieldWallTimer > 0) this.shieldWallTimer -= deltaTime;
            }
            draw() {
                console.log('draw() called');
                // Clear with 8-bit background pattern
                ctx.fillStyle = "#001122";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                // Add subtle 8-bit pattern
                ctx.fillStyle = "#002244";
                for (let x = 0; x < CANVAS_WIDTH; x += 20) {
                    for (let y = 0; y < CANVAS_HEIGHT; y += 20) {
                        if ((x + y) % 40 === 0) {
                            ctx.fillRect(x, y, 2, 2);
                        }
                    }
                }
                if (this.isMainMenu) {
                    console.log('draw() exiting: isMainMenu is true');
                    return;
                }
                // Apply camera transformations
                ctx.save();
                ctx.translate(0, CANVAS_HEIGHT/2);
                ctx.translate(this.camera.shakeX, -CANVAS_HEIGHT/2 + this.camera.shakeY);
                // Draw player base - 8-bit castle
                ctx.fillStyle = "#666666";
                ctx.fillRect(0, 0, BASE_WIDTH, CANVAS_HEIGHT);
                console.log('Base drawn');
                // Draw track lines - 8-bit style
                ctx.strokeStyle = "#004488";
                ctx.lineWidth = 2;
                for (let i = 0; i < this.tracks; i++) {
                    const y = (CANVAS_HEIGHT / (this.tracks + 1)) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(BASE_WIDTH, y);
                    ctx.lineTo(CANVAS_WIDTH, y);
                    ctx.stroke();
                    // Add track markers
                    for (let x = BASE_WIDTH; x < CANVAS_WIDTH; x += 40) {
                        ctx.fillStyle = "#003366";
                        ctx.fillRect(x, y - 1, 4, 2);
                    }
                }
                console.log('Tracks drawn');
                console.log('Drawing units:', this.units.length);
                this.units.forEach(unit => unit.draw(ctx));
                console.log('Drawing enemies:', this.enemies.length);
                this.enemies.forEach(enemy => enemy.draw(ctx));
                ctx.restore();
                // Draw projectiles and particles above the background, below UI
                this.projectiles.forEach(projectile => projectile.draw(ctx));
                this.particles.forEach(particle => particle.draw(ctx));
                // ... rest of draw code ...
            }
            randomizeUnitRules() {
                this.activeUnitRules = {};
                for (let unitType in unitRuleVariants) {
                    const variants = unitRuleVariants[unitType];
                    const selectedVariant = variants[Math.floor(Math.random() * variants.length)];
                    this.activeUnitRules[unitType] = selectedVariant;
                    unitTypes[unitType].requirement = selectedVariant.requirement;
                    unitTypes[unitType].check = selectedVariant.check;
                }
                console.log(`🎲 New ruleset generated!`);
            }
            addToWordLog(word, isSuccess) {
                const wordEntry = {
                    word: word.toUpperCase(),
                    timestamp: Date.now(),
                    isSuccess: isSuccess
                };
                this.wordLog.push(wordEntry);
                updateWordLogDisplay();
            }
            checkForHint() {
                // Move the full checkForHint logic here, using this.state
            }
            // ... other main game logic as methods ...
            gameOver() {
                this.isGameOver = true;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('gameOverScreen').style.display = 'block';
                playSound('gameOver');
            }
            spawnEnemy() {
                const trackIndex = Math.floor(Math.random() * this.tracks);
                const y = (CANVAS_HEIGHT / (this.tracks + 1)) * (trackIndex + 1);

                if (this.wave > 4 && Math.random() < 0.5) {
                    // Spawn two enemies on different tracks
                    let trackIndices = Array.from({length: this.tracks}, (_, i) => i);
                    let t1 = trackIndices.splice(Math.floor(Math.random() * trackIndices.length), 1)[0];
                    let t2 = trackIndices.splice(Math.floor(Math.random() * trackIndices.length), 1)[0];
                    let y1 = (CANVAS_HEIGHT / (this.tracks + 1)) * (t1 + 1);
                    let y2 = (CANVAS_HEIGHT / (this.tracks + 1)) * (t2 + 1);
                // Pick types for each enemy (copy your normal logic for type selection)
                    let type1 = 'bug', type2 = 'bug';
                    const rand = Math.random();
                    if (this.wave % 5 === 0 && this.enemies.filter(e => e.isBoss).length === 0) {
                        type1 = 'rootkit';
                        showFeedback(`⚠️ BOSS INCOMING! ⚠️`, 'error');
                    } else if (this.wave >= 10 && rand < 0.15) {
                        type1 = 'daemon';
                    } else if (this.wave >= 5 && rand < 0.25) {
                        type1 = 'bot';
                    } else if (this.wave >= 3 && rand < 0.3) {
                        type1 = 'worm';
                    } else if (this.wave >= 6 && rand < 0.35) {
                        type1 = 'swarm';
                    }
                    // Second enemy type
                    const rand2 = Math.random();
                    if (this.wave % 5 === 0 && this.enemies.filter(e => e.isBoss).length === 0) {
                        type2 = 'rootkit';
                    } else if (this.wave >= 10 && rand2 < 0.15) {
                        type2 = 'daemon';
                    } else if (this.wave >= 5 && rand2 < 0.25) {
                        type2 = 'bot';
                    } else if (this.wave >= 3 && rand2 < 0.3) {
                        type2 = 'worm';
                    } else if (this.wave >= 6 && rand2 < 0.35) {
                        type2 = 'swarm';
                    }

                    this.enemies.push(new Enemy(CANVAS_WIDTH, y1, type1));
                    this.enemies.push(new Enemy(CANVAS_WIDTH, y2, type2));
                    this.enemiesThisWave += 2;
                    this.enemiesRemaining += 2;
                    console.log('Enemies after pair spawn:', this.enemies.length);
                    // Show PAIR SPAWN banner and play sound
                    const waveBanner = document.getElementById('waveBanner');
                    if (waveBanner) {
                        waveBanner.textContent = 'PAIR SPAWN!';
                        waveBanner.style.background = 'rgba(0,32,128,0.92)';
                        waveBanner.style.color = '#ffff44';
                        waveBanner.style.display = 'block';
                        setTimeout(() => { waveBanner.style.opacity = 1; }, 10);
                        setTimeout(() => { waveBanner.style.opacity = 0; }, 1000);
                        setTimeout(() => { waveBanner.style.display = 'none'; waveBanner.style.background = 'rgba(0,0,0,0.92)'; waveBanner.style.color = '#00ff41'; }, 1600);
                    }
                    playSound('pairSpawn');
                    return;
                }
                // Map logical types to actual enemyTypes keys
                let enemyType = 'bug'; // default
                const rand = Math.random();

                if (this.wave % 5 === 0 && this.enemies.filter(e => e.isBoss).length === 0) {
                    enemyType = 'rootkit'; // boss
                    showFeedback(`⚠️ BOSS INCOMING! ⚠️`, 'error');
                } else if (this.wave >= 10 && rand < 0.15) {
                    enemyType = 'daemon'; // elite
                } else if (this.wave >= 5 && rand < 0.25) {
                    enemyType = 'bot'; // tank
                } else if (this.wave >= 3 && rand < 0.3) {
                    enemyType = 'worm'; // fast
                } else if (this.wave >= 6 && rand < 0.35) {
                    enemyType = 'swarm'; // swarm
                } else if (this.wave >= 5 && rand < 0.4) {
                    enemyType = 'drone';
                }

                this.enemies.push(new Enemy(CANVAS_WIDTH, y, enemyType));
                this.enemiesThisWave++;
                this.enemiesRemaining++;
                console.log('Enemies after spawn:', this.enemies.length);
                if (enemyType === 'swarm') {
                    this.enemies.push(new Enemy(CANVAS_WIDTH, y, 'swarm'));
                    this.enemiesThisWave++;
                    this.enemiesRemaining++;
                    if (Math.random() < 0.3) {
                        // 30% chance to spawn a second swarm nearby
                        const offset = Math.random() < 0.5 ? 10 : -10;
                        this.enemies.push(new Enemy(CANVAS_WIDTH, y + offset, 'swarm'));
                        this.enemiesThisWave++;
                        this.enemiesRemaining++;
                    }
                    return;
                }
                if (this.wave >= 5 && (enemyType === 'drone' || (Math.random() < 0.18 && this.wave >= 5))) {
                    const count = Math.random() < 0.5 ? 2 : 3;
                    for (let i = 0; i < count; i++) {
                        this.enemies.push(new Enemy(CANVAS_WIDTH, y + (i - (count-1)/2) * 18, 'drone'));
                        this.enemiesThisWave++;
                        this.enemiesRemaining++;
                    }
                    return;
                }
            }

            nextWave() {
                this.wave++;
                this.waveTimer = 0;
                this.waveTimeLeft = 30;
                this.nextEnemySpawn = 5000; // First enemy spawns after 5 seconds

                // Reset enemy counters for new wave
                this.enemiesThisWave = 0;
                this.enemiesRemaining = this.enemies.length;

                // Add new track every 2 waves
                if (this.wave % 2 === 0 && this.tracks < 6) {
                    this.tracks++;
                    showFeedback(`NEW TRACK OPENED! WAVE ${this.wave}`, 'success');
                }

                updateDisplay();

                // Show armory every 2 waves starting from wave 3
                if (this.wave % 2 === 1 && this.wave > 2) {
                    this.showArmory();
                } else {
                    showFeedback(`WAVE ${this.wave} BEGINS!`, 'success');
                }

                const waveBanner = document.getElementById('waveBanner');
                if (waveBanner) {
                    waveBanner.textContent = `WAVE ${this.wave} INCOMING!`;
                    waveBanner.style.display = 'block';
                    setTimeout(() => { waveBanner.style.opacity = 1; }, 10);
                    setTimeout(() => { waveBanner.style.opacity = 0; }, 1500);
                    setTimeout(() => { waveBanner.style.display = 'none'; }, 2200);
                }
            }

            showArmory() {
                this.isArmoryOpen = true;
                this.isPaused = true;

                const availableUpgrades = getAvailableUpgrades();
                const selectedUpgrades = [];

                for (let i = 0; i < 3 && availableUpgrades.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * availableUpgrades.length);
                    selectedUpgrades.push(availableUpgrades.splice(randomIndex, 1)[0]);
                }

                const upgradeOptions = document.getElementById('upgradeOptions');
                upgradeOptions.innerHTML = '';

                selectedUpgrades.forEach((upgrade, index) => {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.tabIndex = 0;
                    card.style.cursor = 'pointer';
                    card.innerHTML = `
                        <div class="upgrade-title">${upgrade.name}</div>
                        <div class="upgrade-description">${upgrade.description}</div>
                        <div class="upgrade-stats">${upgrade.stats}</div>
                    `;
                    card.onclick = (e) => { e.stopPropagation(); game.selectUpgrade(upgrade); };
                    card.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); game.selectUpgrade(upgrade); } };
                    upgradeOptions.appendChild(card);
                });

                document.getElementById('armoryScreen').style.display = 'block';
                const armoryScreen = document.getElementById('armoryScreen');
                armoryScreen.classList.remove('armory-animate');
                void armoryScreen.offsetWidth; // force reflow
                armoryScreen.classList.add('armory-animate');
            }

            selectUpgrade(upgrade) {
                upgrade.apply();

                document.getElementById('armoryScreen').style.display = 'none';
                this.isArmoryOpen = false;
                this.isPaused = false;

                showFeedback(`${upgrade.name} ACQUIRED!`, 'success');
                wordInput.focus();
            }
            processWord(word) {
        word = word.toLowerCase().trim();
        if (!word) return;

        // Check word length (4-8 letters only)
        if (word.length < 4 || word.length > 8) {
            this.invalidWordCount++;
            this.consecutiveSuccesses = 0;
            this.addToWordLog(word, false);
            showFeedback("WORDS MUST BE 4-8 LETTERS!", 'error');
            wordInput.classList.add('invalid');
            setTimeout(() => wordInput.classList.remove('invalid'), 500);
            playSound('wordError');
            return;
        }

        // Check for plurals (simple check for 's' ending)
        if (word.endsWith('s') && word.length > 4) {
            this.invalidWordCount++;
            this.consecutiveSuccesses = 0;
            this.addToWordLog(word, false);
            showFeedback("NO PLURALS ALLOWED!", 'error');
            wordInput.classList.add('invalid');
            setTimeout(() => wordInput.classList.remove('invalid'), 500);
            playSound('wordError');
            return;
        }

        if (this.usedWords.has(word)) {
            this.invalidWordCount++;
            this.consecutiveSuccesses = 0;
            this.addToWordLog(word, false);
            showFeedback("WORD ALREADY USED!", 'error');
            wordInput.classList.add('invalid');
            setTimeout(() => wordInput.classList.remove('invalid'), 500);
            playSound('wordError');
            this.checkForHint();
            return;
        }

        if (!WORD_DICTIONARY.has(word)) {
            this.invalidWordCount++;
            this.consecutiveSuccesses = 0;
            this.addToWordLog(word, false);
            showFeedback("INVALID WORD!", 'error');
            wordInput.classList.add('invalid');
            setTimeout(() => wordInput.classList.remove('invalid'), 500);
            playSound('wordError');
            this.checkForHint();
            return;
        }

        const summonedUnits = [];
        // Only check unlocked unit types
        for (let [unitType, unitData] of Object.entries(unitTypes)) {
            if (this.unlockedUnits.has(unitType) && unitData.check(word)) {
                summonedUnits.push(unitType);
            }
        }

        if (summonedUnits.length === 0) {
            this.invalidWordCount++;
            this.consecutiveSuccesses = 0;
            this.addToWordLog(word, false);
            showFeedback("NO UNITS MATCH WORD PATTERN!", 'error');
            wordInput.classList.add('invalid');
            setTimeout(() => wordInput.classList.remove('invalid'), 500);
            playSound('wordError');
            this.checkForHint();
            return;
        }

        // Success!
        this.invalidWordCount = 0;
        this.consecutiveSuccesses++;
        this.usedWords.add(word);
        this.addToWordLog(word, true);

        // Calculate score with bonuses
        const baseScore = word.length * 10;
        const complexityBonus = summonedUnits.length * 5;
        const consecutiveBonus = Math.min(this.consecutiveSuccesses * 2, 20);
        const totalScore = baseScore + complexityBonus + consecutiveBonus;
        this.score += totalScore;

        // Spawn units just right of the base
        for (let unitType of summonedUnits) {
            const x = BASE_WIDTH + 30 + Math.random() * 50;
            const y = 100 + Math.random() * (CANVAS_HEIGHT - 200);
            if (unitType === 'blocker' && this.upgrades.special.blockerDouble) {
                this.units.push(new Unit(unitType, x, y));
                this.units.push(new Unit(unitType, x + 18, y + 8));
                createParticles(x, y, 8, unitTypes[unitType].color, 1);
                createParticles(x + 18, y + 8, 8, unitTypes[unitType].color, 1);
            } else {
                const newUnit = new Unit(unitType, x, y);
                // Ping Speed Boost
                if (unitType === 'ping' && this.upgrades.special.pingSpeed) {
                    newUnit.speedBoostTimer = 5000;
                }
                this.units.push(newUnit);
                createParticles(x, y, 8, unitTypes[unitType].color, 1);
            }
            // Patch Mass Heal
            if (unitType === 'patch' && this.upgrades.special.patchMassHeal) {
                for (let unit of this.units) {
                    unit.health = Math.min(unit.maxHealth, unit.health + 1);
                    createParticles(unit.x, unit.y, 4, '#44ffaa', 0.7);
                }
                showFeedback('MASS HEAL: ALL UNITS +1 HEALTH!', 'success');
                // Show MASS HEAL banner and play sound
                const waveBanner = document.getElementById('waveBanner');
                if (waveBanner) {
                    waveBanner.textContent = 'MASS HEAL!';
                    waveBanner.style.background = 'rgba(0,128,64,0.92)';
                    waveBanner.style.color = '#44ff44';
                    waveBanner.style.display = 'block';
                    setTimeout(() => { waveBanner.style.opacity = 1; }, 10);
                    setTimeout(() => { waveBanner.style.opacity = 0; }, 1000);
                    setTimeout(() => { waveBanner.style.display = 'none'; waveBanner.style.background = 'rgba(0,0,0,0.92)'; waveBanner.style.color = '#00ff41'; }, 1600);
                }
                playSound('massHeal');
            }
        }

        // Sound effects and feedback
        if (summonedUnits.length >= 3) {
            playSound('wordExcellent');
            addScreenShake(2, 150);
        } else if (word.length >= 7) {
            playSound('wordGreat');
        } else {
            playSound('wordGood');
        }

        const bonusText = consecutiveBonus > 0 ? ` (+${consecutiveBonus} STREAK!)` : '';
        const unitNames = summonedUnits.map(u => unitTypes[u].name.toUpperCase()).join(', ');
        showFeedback(`SUMMONED ${unitNames}! +${totalScore}${bonusText}`, 'success');
        updateDisplay();
    }
        }


        // Ensure only one instance of the game is created after the class definition
        let game = new GlyphGuardGame();

        // Add the correct game loop function
        let lastTime = 0;
        function gameLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (!game.isGameOver && !game.isPaused && !game.isMainMenu) {
                game.update(deltaTime);
            }
            game.draw();
            requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);

        // Ensure the word input event listener is present and correct
        wordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !game.isMainMenu && !game.isGameOver && !game.isPaused) {
                game.processWord(this.value);
                this.value = '';
            }
        });

        document.getElementById('helpBtn').onclick = function() {
          document.getElementById('helpModal').style.display = 'block';
        };
        document.getElementById('closeHelpBtn').onclick = function() {
          document.getElementById('helpModal').style.display = 'none';
        };

        // 1. Define evolved unit types and their rules
        const evolvedUnitTypes = {
            blocker: {
                name: 'Firewall', color: '#ff8844', symbol: '🔥', shape: 'square', health: 5, damage: 3, speed: 0.45, range: 40, isMelee: true,
                requirement: '5+ letters, contains F or W',
                check: word => word.length >= 5 && word.length <= 8 && /[fw]/i.test(word)
            },
            sentry: {
                name: 'Sniper', color: '#44ffff', symbol: '🎯', shape: 'triangle', health: 2, damage: 4, speed: 0.22, range: 350, isMelee: false,
                requirement: '5+ letters, ends with R or S',
                check: word => word.length >= 5 && word.length <= 8 && /[rs]$/i.test(word)
            },
            lancer: {
                name: 'Phantom', color: '#ffaaee', symbol: '👻', shape: 'diamond', health: 3, damage: 4, speed: 1.0, range: 40, isMelee: true,
                requirement: '6+ letters, contains PH or GH',
                check: word => word.length >= 6 && word.length <= 8 && /(ph|gh)/i.test(word)
            },
            defender: {
                name: 'Bastion', color: '#aaaaff', symbol: '🏰', shape: 'pentagon', health: 8, damage: 2, speed: 0.13, range: 50, isMelee: true,
                requirement: '6+ letters, starts with B or ends with N',
                check: word => word.length >= 6 && word.length <= 8 && (/^b/i.test(word) || /n$/i.test(word))
            },
            buster: {
                name: 'Overloader', color: '#ff66ff', symbol: '⚡', shape: 'hexagon', health: 3, damage: 12, speed: 0.12, range: 350, isMelee: false, isAreaDamage: true,
                requirement: '7+ letters, contains V or double letter',
                check: word => word.length >= 7 && word.length <= 8 && (/[v]/i.test(word) || /(\w)\1/.test(word))
            },
            scripter: {
                name: 'Hacker', color: '#44aaff', symbol: '💻', shape: 'star', health: 2, damage: 6, speed: 0.25, range: 220, isMelee: false, isAreaDamage: true,
                requirement: '6+ letters, at least 3 vowels',
                check: word => word.length >= 6 && word.length <= 8 && ((word.match(/[aeiou]/gi)||[]).length >= 3)
            },
            patch: {
                name: 'Medic', color: '#44ffee', symbol: '💊', shape: 'circle', health: 2, damage: 0, speed: 0.35, range: 120, isMelee: false, isHealer: true,
                requirement: '7+ letters, ends with AL or IC',
                check: word => word.length >= 7 && word.length <= 8 && /(al|ic)$/i.test(word)
            },
            ping: {
                name: 'Tracer', color: '#44ffcc', symbol: '🛰️', shape: 'oval', health: 2, damage: 2, speed: 1.5, range: 80, isMelee: true,
                requirement: '5+ letters, all unique, starts with T',
                check: word => word.length >= 5 && word.length <= 8 && /^[t]/i.test(word) && (new Set(word).size === word.length)
            }
        };

        // 2. Track upgrades for each unit type
        if (!window.unitUpgradeCounts) window.unitUpgradeCounts = {};
        for (const unit of Object.keys(unitTypes)) {
            if (!(unit in window.unitUpgradeCounts)) window.unitUpgradeCounts[unit] = 0;
        }
        if (!game.upgrades.evolutions) game.upgrades.evolutions = {};




        // 5. Enemy scaling system
        if (!game.enemyScaling) game.enemyScaling = { size: 1, health: 0 };
        const originalNextWave = game.nextWave;
        game.nextWave = function() {
            if ((this.wave + 1) % 3 === 0) {
                game.enemyScaling.size += 0.1;
                game.enemyScaling.health += 1;
            }
            originalNextWave.call(this);
        };
        // Patch Enemy class to apply scaling
        const OriginalEnemy = Enemy;
        Enemy = function(x, y, type = 'basic') {
            const scaling = game.enemyScaling || { size: 1, health: 0 };
            const base = enemyTypes[type];
            let sizeMult = scaling.size;
            let healthBonus = scaling.health;
            if (base.isElite) { sizeMult *= 2; healthBonus *= 2; }
            if (base.isBoss) { sizeMult *= 3; healthBonus *= 3; }
            const enemy = new OriginalEnemy(x, y, type);
            enemy.size = Math.round(base.size * sizeMult);
            enemy.health = enemy.maxHealth = base.health + healthBonus;
            return enemy;
        };

        // 1. Define multi-stage evolved unit types and their rules
        const evolvedUnitTrees = {
            blocker: [
                {
                    name: 'Firewall', color: '#ff8844', symbol: '🔥', shape: 'square', health: 5, damage: 3, speed: 0.45, range: 40, isMelee: true,
                    requirement: '5+ letters, contains F or W',
                    check: word => word.length >= 5 && word.length <= 8 && /[fw]/i.test(word)
                },
                {
                    name: 'Gatekeeper', color: '#ffbb00', symbol: '🚪', shape: 'square', health: 8, damage: 5, speed: 0.5, range: 50, isMelee: true,
                    requirement: '6+ letters, contains G or double letter',
                    check: word => word.length >= 6 && word.length <= 8 && (/[g]/i.test(word) || /(\w)\1/.test(word))
                }
            ],
            sentry: [
                {
                    name: 'Sniper', color: '#44ffff', symbol: '🎯', shape: 'triangle', health: 2, damage: 4, speed: 0.22, range: 350, isMelee: false,
                    requirement: '5+ letters, ends with R or S',
                    check: word => word.length >= 5 && word.length <= 8 && /[rs]$/i.test(word)
                },
                {
                    name: 'Railgunner', color: '#00e0ff', symbol: '🔫', shape: 'triangle', health: 3, damage: 7, speed: 0.18, range: 500, isMelee: false,
                    requirement: '6+ letters, contains Q or Z',
                    check: word => word.length >= 6 && word.length <= 8 && (/[qz]/i.test(word))
                }
            ],
            lancer: [
                {
                    name: 'Phantom', color: '#ffaaee', symbol: '👻', shape: 'diamond', health: 3, damage: 4, speed: 1.0, range: 40, isMelee: true,
                    requirement: '6+ letters, contains PH or GH',
                    check: word => word.length >= 6 && word.length <= 8 && /(ph|gh)/i.test(word)
                },
                {
                    name: 'Specter', color: '#fff0ff', symbol: '🦴', shape: 'diamond', health: 4, damage: 6, speed: 1.3, range: 60, isMelee: true,
                    requirement: '7+ letters, contains S or X',
                    check: word => word.length >= 7 && word.length <= 8 && (/[sx]/i.test(word))
                }
            ],
            defender: [
                {
                    name: 'Bastion', color: '#aaaaff', symbol: '🏰', shape: 'pentagon', health: 8, damage: 2, speed: 0.13, range: 50, isMelee: true,
                    requirement: '6+ letters, starts with B or ends with N',
                    check: word => word.length >= 6 && word.length <= 8 && (/^b/i.test(word) || /n$/i.test(word))
                },
                {
                    name: 'Citadel', color: '#e0e0ff', symbol: '🛡️', shape: 'pentagon', health: 12, damage: 3, speed: 0.15, range: 60, isMelee: true,
                    requirement: '7+ letters, contains C or D',
                    check: word => word.length >= 7 && word.length <= 8 && (/[cd]/i.test(word))
                }
            ],
            buster: [
                {
                    name: 'Overloader', color: '#ff66ff', symbol: '⚡', shape: 'hexagon', health: 3, damage: 12, speed: 0.12, range: 350, isMelee: false, isAreaDamage: true,
                    requirement: '7+ letters, contains V or double letter',
                    check: word => word.length >= 7 && word.length <= 8 && (/[v]/i.test(word) || /(\w)\1/.test(word))
                },
                {
                    name: 'Annihilator', color: '#ff00ff', symbol: '💣', shape: 'hexagon', health: 4, damage: 18, speed: 0.14, range: 600, isMelee: false, isAreaDamage: true,
                    requirement: '8 letters, contains A or I',
                    check: word => word.length === 8 && (/[ai]/i.test(word))
                }
            ],
            scripter: [
                {
                    name: 'Hacker', color: '#44aaff', symbol: '💻', shape: 'star', health: 2, damage: 6, speed: 0.25, range: 220, isMelee: false, isAreaDamage: true,
                    requirement: '6+ letters, at least 3 vowels',
                    check: word => word.length >= 6 && word.length <= 8 && ((word.match(/[aeiou]/gi)||[]).length >= 3)
                },
                {
                    name: 'Rootuser', color: '#00ffff', symbol: '🧠', shape: 'star', health: 3, damage: 10, speed: 0.22, range: 300, isMelee: false, isAreaDamage: true,
                    requirement: '7+ letters, contains R or U',
                    check: word => word.length >= 7 && word.length <= 8 && (/[ru]/i.test(word))
                }
            ],
            patch: [
                {
                    name: 'Medic', color: '#44ffee', symbol: '💊', shape: 'circle', health: 2, damage: 0, speed: 0.35, range: 120, isMelee: false, isHealer: true,
                    requirement: '7+ letters, ends with AL or IC',
                    check: word => word.length >= 7 && word.length <= 8 && /(al|ic)$/i.test(word)
                },
                {
                    name: 'Synth', color: '#00ffcc', symbol: '🧬', shape: 'circle', health: 3, damage: 0, speed: 0.4, range: 160, isMelee: false, isHealer: true,
                    requirement: '8 letters, contains S or Y',
                    check: word => word.length === 8 && (/[sy]/i.test(word))
                }
            ],
            ping: [
                {
                    name: 'Tracer', color: '#44ffcc', symbol: '🛰️', shape: 'oval', health: 2, damage: 2, speed: 1.5, range: 80, isMelee: true,
                    requirement: '5+ letters, all unique, starts with T',
                    check: word => word.length >= 5 && word.length <= 8 && /^[t]/i.test(word) && (new Set(word).size === word.length)
                },
                {
                    name: 'Ghost', color: '#ffffff', symbol: '👾', shape: 'oval', health: 3, damage: 3, speed: 2.0, range: 120, isMelee: true,
                    requirement: '6+ letters, contains G or H',
                    check: word => word.length >= 6 && word.length <= 8 && (/[gh]/i.test(word))
                }
            ]
        };
        // Helper to get current evolution stage
        function getUnitEvolutionStage(unitType) {
            return game.upgrades.evolutions[unitType] || 0;
        }
        // Patch getAvailableUpgrades to offer multi-stage evolutions
        const originalGetAvailableUpgrades = getAvailableUpgrades;
        getAvailableUpgrades = function() {
            const available = originalGetAvailableUpgrades();
            for (let unitType of game.unlockedUnits) {
                const currentStage = getUnitEvolutionStage(unitType);
                const tree = evolvedUnitTrees[unitType];
                if (tree && currentStage < tree.length && window.unitUpgradeCounts[unitType] > currentStage) {
                    const nextStage = tree[currentStage];
                    available.push({
                        name: `EVOLVE: ${unitTypes[unitType].name.toUpperCase()} → ${nextStage.name.toUpperCase()}`,
                        description: `Evolve ${unitTypes[unitType].name} into ${nextStage.name} with new word rules and abilities!`,
                        stats: `NEW: ${nextStage.requirement.toUpperCase()}`,
                        type: 'evolution',
                        unitType,
                        apply: () => {
                            unitTypes[unitType] = { ...nextStage };
                            game.upgrades.evolutions[unitType] = currentStage + 1;
                            updateUnitGuide();
                        }
                    });
                }
            }
            return available;
        };
    </script>
</body>
</html>
